//--------------------------------------------------------------------------------------------------------------
// Autogenerated file -- DO NOT EDIT
//
// This header contains:
// * FPGA version constants (can be used to check if FPGA is compatible with this version of the register API)
// * FPGA DMA channel constants
// * Register and register field specifiers
// * Functions for reading and writing 32-bit registers or fields, depending on the specifier provided
// * Functions for inserting and extracting field values from 32-bit ints
// * Introspection functions (look up ASCII register name given a specifier, or vice versa)
//
// Specifiers are 64-bit unsigned integer constants with the following structure:
//    bits 63:56 : If specifier is a field, field width in bits.
//    bits 55:48 : If specifier is a field, field offset in bits.
//    bits 47:0  : Register address (usually relative to a base address).
// If the field width and offset are both 0, the specifier is a whole-register specifier, and may be
// treated as an address.
//--------------------------------------------------------------------------------------------------------------

#ifndef _FPGA_REG_H
#define _FPGA_REG_H

#include <stdint.h>

typedef struct {
    const uint64_t specifier;
    const char * const name;
} regname_lookup_entry_T;

extern regname_lookup_entry_T regname_table[];
 
#define foo   0x0401000000002000ULL

//
// Macros to extract fields from register specifier constants
//
#define FPGA_RS_IS_FIELD(spec)    (((uint64_t)(spec) & 0xffff000000000000ULL) != 0ULL)
#define FPGA_RS_GET_ADDRESS(spec) (((uint64_t)(spec) & 0x0000ffffffffffffULL)        )
#define FPGA_RS_GET_WIDTH(spec)   (((uint64_t)(spec) >> 56) & 0xffULL)
#define FPGA_RS_GET_OFFSET(spec)  (((uint64_t)(spec) >> 48) & 0xffULL)

//
// Set base address. Must be called before using fpgareg_read() / fpgareg_write().
//
void fpgareg_set_base_address(void *p);

//
// Read FPGA register or field
//
uint32_t fpgareg_read(uint64_t specifier);

//
// Write FPGA register or field (generates read-modify-write if a field)
//
void fpgareg_write(uint64_t specifier, uint32_t val);

//
// Returns a version of register_value modified by setting the field described by specifier to field_value.
//
uint32_t fpgareg_setfield(uint32_t register_value, uint64_t specifier, uint32_t field_value);

//
// Return the field described by specifier from register_value.
//
uint32_t fpgareg_getfield(uint32_t register_value, uint64_t specifier);

//
// Return the ASCII name corresponding to a register or field specifier, or NULL if the specifier is invalid.
//
const char * fpgareg_specifier_to_regname(uint64_t specifier);

//
// Return the specifier corresponding to an ASCII name, or 0xffffffffffffffffULL if the name is invalid.
//
uint64_t fpgareg_regname_to_specifier(const char *name);


//--------------------------------------------------------------------------------------------------------------
// FPGA VERSION CONSTANTS
//--------------------------------------------------------------------------------------------------------------
#define FPGA_GIT_HASH "c82465e43a2963326510b1b4980ab341a745e315"
#define FPGA_VERSION_MAJOR                                           0x00000000UL
#define FPGA_VERSION_MINOR                                           0x00000004UL
#define FPGA_VERSION_PATCH                                           0x00000000UL


//--------------------------------------------------------------------------------------------------------------
// FPGA DMA CHANNEL CONSTANTS
//--------------------------------------------------------------------------------------------------------------
#define LVDS_DMA_CHAN_RECORDING_MAP0_RD                              0x00000001UL
#define LVDS_DMA_CHAN_ARB_WAVEFORM0_RD                               0x00000002UL
#define LVDS_DMA_CHAN_ARB_WAVEFORM1_RD                               0x00000003UL
#define LVDS_DMA_CHAN_RECORDING_MAP1_RD                              0x00000004UL
#define LVDS_DMA_CHAN_DDR_FRAME_DATA0_WR                             0x00000000UL
#define LVDS_DMA_CHAN_DDR_FRAME_DATA1_WR                             0x00000005UL
#define DP_DMA_CHAN_DDR_HOST_DATA                                    0x00000005UL
#define DP_DMA_CHAN_PCIE_HOST_DATA                                   0x00000006UL
#define DP_DMA_CHAN_SRAM_HOST_DATA                                   0x00000000UL
#define DP_DMA_CHAN_DDR_FRAME_DATA0_RD                               0x00000000UL
#define DP_DMA_CHAN_PCIE_FRAME_DATA0_WR                              0x00000001UL
#define DP_DMA_CHAN_PCIE_FRAME_HDR_TIMESTAMP0_WR                     0x00000002UL
#define DP_DMA_CHAN_PCIE_FRAME_HDR_ADC0_WR                           0x00000003UL
#define DP_DMA_CHAN_PCIE_FRAME_HDR_FG_CNT0_WR                        0x00000004UL
#define DP_DMA_CHAN_RECORDING_MAP0_RD                                0x00000007UL
#define DP_DMA_CHAN_PCIE_FRAME_HDR_STATUS0_WR                        0x00000008UL
#define DP_DMA_CHAN_DDR_FRAME_DATA1_RD                               0x00000009UL
#define DP_DMA_CHAN_PCIE_FRAME_DATA1_WR                              0x0000000aUL
#define DP_DMA_CHAN_PCIE_FRAME_HDR_TIMESTAMP1_WR                     0x0000000bUL
#define DP_DMA_CHAN_PCIE_FRAME_HDR_ADC1_WR                           0x0000000cUL
#define DP_DMA_CHAN_PCIE_FRAME_HDR_FG_CNT1_WR                        0x0000000dUL
#define DP_DMA_CHAN_RECORDING_MAP1_RD                                0x0000000eUL
#define DP_DMA_CHAN_PCIE_FRAME_HDR_STATUS1_WR                        0x0000000fUL
#define DP_DMA_CHAN_DEAC_HSI_BITMAP00_RD                             0x00000010UL
#define DP_DMA_CHAN_DEAC_HSI_BITMAP01_RD                             0x00000011UL
#define DP_DMA_CHAN_DEAC_HSI_BITMAP02_RD                             0x00000012UL
#define DP_DMA_CHAN_DEAC_HSI_BITMAP03_RD                             0x00000013UL
#define DP_DMA_CHAN_DEAC_FGP_BITMAP00_RD                             0x00000014UL
#define DP_DMA_CHAN_DEAC_FGP_BITMAP01_RD                             0x00000015UL
#define DP_DMA_CHAN_DEAC_FGP_BITMAP02_RD                             0x00000016UL
#define DP_DMA_CHAN_DEAC_FGP_BITMAP03_RD                             0x00000017UL
#define DP_DMA_CHAN_DEAC_FGP_BITMAP00_WR                             0x00000018UL
#define DP_DMA_CHAN_DEAC_FGP_BITMAP01_WR                             0x00000019UL
#define DP_DMA_CHAN_DEAC_FGP_BITMAP02_WR                             0x0000001aUL
#define DP_DMA_CHAN_DEAC_FGP_BITMAP03_WR                             0x0000001bUL
#define DP_DMA_CHAN_DEAC0_VOTECNT0_RD                                0x00000020UL
#define DP_DMA_CHAN_DEAC1_VOTECNT0_RD                                0x00000021UL
#define DP_DMA_CHAN_DEAC2_VOTECNT0_RD                                0x00000022UL
#define DP_DMA_CHAN_DEAC0_VOTECNT0_WR                                0x00000023UL
#define DP_DMA_CHAN_DEAC1_VOTECNT0_WR                                0x00000024UL
#define DP_DMA_CHAN_DEAC2_VOTECNT0_WR                                0x00000025UL
#define DP_DMA_CHAN_DEAC0_STATICFRAME0_RD                            0x00000026UL
#define DP_DMA_CHAN_DEAC1_STATICFRAME0_RD                            0x00000027UL
#define DP_DMA_CHAN_DEAC2_STATICFRAME0_RD                            0x00000028UL
#define DP_DMA_CHAN_DEAC0_STATICFRAME1_RD                            0x00000029UL
#define DP_DMA_CHAN_DEAC1_STATICFRAME1_RD                            0x0000002aUL
#define DP_DMA_CHAN_DEAC2_STATICFRAME1_RD                            0x0000002bUL
#define DP_DMA_CHAN_DEAC_HSI_BITMAP10_RD                             0x00000030UL
#define DP_DMA_CHAN_DEAC_HSI_BITMAP11_RD                             0x00000031UL
#define DP_DMA_CHAN_DEAC_HSI_BITMAP12_RD                             0x00000032UL
#define DP_DMA_CHAN_DEAC_HSI_BITMAP13_RD                             0x00000033UL
#define DP_DMA_CHAN_DEAC_FGP_BITMAP10_RD                             0x00000034UL
#define DP_DMA_CHAN_DEAC_FGP_BITMAP11_RD                             0x00000035UL
#define DP_DMA_CHAN_DEAC_FGP_BITMAP12_RD                             0x00000036UL
#define DP_DMA_CHAN_DEAC_FGP_BITMAP13_RD                             0x00000037UL
#define DP_DMA_CHAN_DEAC_FGP_BITMAP10_WR                             0x00000038UL
#define DP_DMA_CHAN_DEAC_FGP_BITMAP11_WR                             0x00000039UL
#define DP_DMA_CHAN_DEAC_FGP_BITMAP12_WR                             0x0000003aUL
#define DP_DMA_CHAN_DEAC_FGP_BITMAP13_WR                             0x0000003bUL
#define DP_DMA_CHAN_DEAC0_VOTECNT1_RD                                0x0000003cUL
#define DP_DMA_CHAN_DEAC1_VOTECNT1_RD                                0x0000003dUL
#define DP_DMA_CHAN_DEAC2_VOTECNT1_RD                                0x0000003eUL
#define DP_DMA_CHAN_DEAC0_VOTECNT1_WR                                0x0000003fUL
#define DP_DMA_CHAN_DEAC1_VOTECNT1_WR                                0x00000040UL
#define DP_DMA_CHAN_DEAC2_VOTECNT1_WR                                0x00000041UL
#define DP_DMA_CHAN_DEAC0_STATICFRAME0_WR                            0x00000042UL
#define DP_DMA_CHAN_DEAC1_STATICFRAME0_WR                            0x00000043UL
#define DP_DMA_CHAN_DEAC2_STATICFRAME0_WR                            0x00000044UL
#define DP_DMA_CHAN_DEAC0_STATICFRAME1_WR                            0x00000045UL
#define DP_DMA_CHAN_DEAC1_STATICFRAME1_WR                            0x00000046UL
#define DP_DMA_CHAN_DEAC2_STATICFRAME1_WR                            0x00000047UL


//--------------------------------------------------------------------------------------------------------------
// FPGA MEMORY MAP CONSTANTS
//--------------------------------------------------------------------------------------------------------------
#define Q0_RBM_BASEADDR                                              0x0000000000000000ULL
#define Q1_RBM_BASEADDR                                              0x0000000000040000ULL
#define Q2_RBM_BASEADDR                                              0x0000000000080000ULL
#define Q3_RBM_BASEADDR                                              0x00000000000c0000ULL
#define Q0_MIRROR_BASEADDR                                           0x0000000000100000ULL
#define Q1_MIRROR_BASEADDR                                           0x0000000000140000ULL
#define Q2_MIRROR_BASEADDR                                           0x0000000000180000ULL
#define Q3_MIRROR_BASEADDR                                           0x00000000001c0000ULL
#define Q0_RBM_SIZE                                                  0x0000000000040000ULL
#define Q1_RBM_SIZE                                                  0x0000000000040000ULL
#define Q2_RBM_SIZE                                                  0x0000000000040000ULL
#define Q3_RBM_SIZE                                                  0x0000000000040000ULL
#define Q0_MIRROR_SIZE                                               0x0000000000040000ULL
#define Q1_MIRROR_SIZE                                               0x0000000000040000ULL
#define Q2_MIRROR_SIZE                                               0x0000000000040000ULL
#define Q3_MIRROR_SIZE                                               0x0000000000040000ULL


//--------------------------------------------------------------------------------------------------------------
// FPGA REGISTER / FIELD SPECIFIER CONSTANTS
//--------------------------------------------------------------------------------------------------------------

//
// Register:    GLOBAL_FPGA_SIGNATURE1
// Description: FPGA Global Signature 1 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     sig                            32  31:00 RO   0x4d385046  Part 1 of magic value for detecting FPGA type. Contains the
//                                                               ASCII string FP8M, or 0x4d385046.
//
#define GLOBAL_FPGA_SIGNATURE1                                       0x0000000000000000ULL
#define GLOBAL_FPGA_SIGNATURE1_sig                                   0x2000000000000000ULL

//
// Register:    GLOBAL_FPGA_SIGNATURE2
// Description: FPGA Global Signature 2 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     sig                            32  31:00 RO   0x4c474e41  Part 2 of magic value for detecting FPGA type. Contains the
//                                                               ASCII string LGNA, or 0x4c474e41.
//
#define GLOBAL_FPGA_SIGNATURE2                                       0x0000000000000004ULL
#define GLOBAL_FPGA_SIGNATURE2_sig                                   0x2000000000000004ULL

//
// Register:    GLOBAL_FPGA_REV
// Description: FPGA Revision
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     patch                          12  11:00 RO   0x0         FPGA Revision: patch (follows Semantic Versioning 2.0.0,
//                                                               semver.org)
//     minor                          10  21:12 RO   0x4         FPGA Revision: minor (follows Semantic Versioning 2.0.0,
//                                                               semver.org)
//     major                          10  31:22 RO   0x0         FPGA Revision: major (follows Semantic Versioning 2.0.0,
//                                                               semver.org)
//
#define GLOBAL_FPGA_REV                                              0x0000000000000008ULL
#define GLOBAL_FPGA_REV_patch                                        0x0c00000000000008ULL
#define GLOBAL_FPGA_REV_minor                                        0x0a0c000000000008ULL
#define GLOBAL_FPGA_REV_major                                        0x0a16000000000008ULL

//
// Register:    GLOBAL_FPGA_BOARD_ID
// Description: FPGA Board Identification
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     board_type                     4   03:00 RO   0x0         Board type. 0=VC709 (obsolete, no longer supported),
//                                                               1=NASCAR, 2=Soapbox. All other values reserved.
//     board_rev                      3   06:04 RO   0x0         Board revision code (from strap resistors). 0-based, so code
//                                                               0 is revision 1, code 1 is rev 2, etc.
//     spare_straps                   5   11:07 RO   0x0         Spare strap resistors
//
#define GLOBAL_FPGA_BOARD_ID                                         0x000000000000000cULL
#define GLOBAL_FPGA_BOARD_ID_board_type                              0x040000000000000cULL
#define GLOBAL_FPGA_BOARD_ID_board_rev                               0x030400000000000cULL
#define GLOBAL_FPGA_BOARD_ID_spare_straps                            0x050700000000000cULL

//
// Register:    GLOBAL_FPGA_GIT_HASH0
// Description: Word 0 of the Git hash this FPGA was built from.
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     hash                           32  31:00 RO   0x0         32-bit word 0 of the Git hash this FPGA was built from.
//
#define GLOBAL_FPGA_GIT_HASH0                                        0x0000000000000010ULL
#define GLOBAL_FPGA_GIT_HASH0_hash                                   0x2000000000000010ULL

//
// Register:    GLOBAL_FPGA_GIT_HASH1
// Description: Word 1 of the Git hash this FPGA was built from.
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     hash                           32  31:00 RO   0x0         32-bit word 1 of the Git hash this FPGA was built from.
//
#define GLOBAL_FPGA_GIT_HASH1                                        0x0000000000000014ULL
#define GLOBAL_FPGA_GIT_HASH1_hash                                   0x2000000000000014ULL

//
// Register:    GLOBAL_FPGA_GIT_HASH2
// Description: Word 2 of the Git hash this FPGA was built from.
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     hash                           32  31:00 RO   0x0         32-bit word 2 of the Git hash this FPGA was built from.
//
#define GLOBAL_FPGA_GIT_HASH2                                        0x0000000000000018ULL
#define GLOBAL_FPGA_GIT_HASH2_hash                                   0x2000000000000018ULL

//
// Register:    GLOBAL_FPGA_GIT_HASH3
// Description: Word 3 of the Git hash this FPGA was built from.
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     hash                           32  31:00 RO   0x0         32-bit word 3 of the Git hash this FPGA was built from.
//
#define GLOBAL_FPGA_GIT_HASH3                                        0x000000000000001cULL
#define GLOBAL_FPGA_GIT_HASH3_hash                                   0x200000000000001cULL

//
// Register:    GLOBAL_FPGA_GIT_HASH4
// Description: Word 4 of the Git hash this FPGA was built from.
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     hash                           32  31:00 RO   0x0         32-bit word 4 of the Git hash this FPGA was built from.
//
#define GLOBAL_FPGA_GIT_HASH4                                        0x0000000000000020ULL
#define GLOBAL_FPGA_GIT_HASH4_hash                                   0x2000000000000020ULL

//
// Register:    GLOBAL_FPGA_GIT_HASH5
// Description: Word 5 of the Git hash this FPGA was built from.
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     hash                           32  31:00 RO   0x0         32-bit word 5 of the Git hash this FPGA was built from.
//
#define GLOBAL_FPGA_GIT_HASH5                                        0x0000000000000024ULL
#define GLOBAL_FPGA_GIT_HASH5_hash                                   0x2000000000000024ULL

//
// Register:    GLOBAL_FPGA_GIT_HASH6
// Description: Word 6 of the Git hash this FPGA was built from.
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     hash                           32  31:00 RO   0x0         32-bit word 6 of the Git hash this FPGA was built from.
//
#define GLOBAL_FPGA_GIT_HASH6                                        0x0000000000000028ULL
#define GLOBAL_FPGA_GIT_HASH6_hash                                   0x2000000000000028ULL

//
// Register:    GLOBAL_FPGA_GIT_HASH7
// Description: Word 7 of the Git hash this FPGA was built from.
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     hash                           32  31:00 RO   0x0         32-bit word 7 of the Git hash this FPGA was built from.
//
#define GLOBAL_FPGA_GIT_HASH7                                        0x000000000000002cULL
#define GLOBAL_FPGA_GIT_HASH7_hash                                   0x200000000000002cULL

//
// Register:    GLOBAL_CLK_LVDS1X_CFG
// Description: LVDS 1x MMCM control
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     din                            16  15:00 RW   0x0         MMCM DRP port data in
//     daddr                          7   22:16 RW   0x0         MMCM DRP port address
//     dwe                            1      23 RW   0x0         MMCM DRP port write enable
//     den                            1      24 RW   0x0         MMCM DRP port enable (0 to 1 transition triggers a DRP port
//                                                               read or write operation)
//     rst                            1      25 RW   0x0         When 1, LVDS clock outputs are disabled and all four LVDS
//                                                               MMCMs are put into reset. When 0, LVDS clock outputs are
//                                                               enabled and all four LVDS MMCMs are released from reset.
//                                                               Transitions between 0 and 1 invoke a state machine which
//                                                               sequences operations so that the LVDS clocks sent to the
//                                                               chip and most of the FPGA make glitchless transitions. To
//                                                               reprogram LVDS clock frequency, first set this bit to 1,
//                                                               wait for 1ms, reprogram the MMCMs with new settings, then
//                                                               program this bit to 0 and wait for all four
//                                                               GLOBAL_CLK_LVDS*_STATUS_locked bits to go to 1.
//
#define GLOBAL_CLK_LVDS1X_CFG                                        0x0000000000000100ULL
#define GLOBAL_CLK_LVDS1X_CFG_din                                    0x1000000000000100ULL
#define GLOBAL_CLK_LVDS1X_CFG_daddr                                  0x0710000000000100ULL
#define GLOBAL_CLK_LVDS1X_CFG_dwe                                    0x0117000000000100ULL
#define GLOBAL_CLK_LVDS1X_CFG_den                                    0x0118000000000100ULL
#define GLOBAL_CLK_LVDS1X_CFG_rst                                    0x0119000000000100ULL

//
// Register:    GLOBAL_CLK_LVDS1X_STATUS
// Description: LVDS 1x MMCM status
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     dout                           16  15:00 RO   0x0         MMCM DRP port data out
//     drdy                           1      16 RW1C 0x0         MMCM DRP port ready. Latched, write 1 to clear. Goes high to
//                                                               acknowledge a successful DRP port read or write.
//     locked                         1      17 RO   0x0         MMCM locked status.
//     clkinstopped                   1      18 RW1C 0x0         MMCM clock input stopped. Latched, write 1 to clear.
//     clkfbstopped                   1      19 RW1C 0x0         MMCM feedback clock stopped. Latched, write 1 to clear.
//     output_freq_ctr                12  31:20 RO   0x0         Output frequency counter. Divide value by 10.0 to compute
//                                                               LVDS1X clock frequency in MHz.
//
#define GLOBAL_CLK_LVDS1X_STATUS                                     0x0000000000000104ULL
#define GLOBAL_CLK_LVDS1X_STATUS_dout                                0x1000000000000104ULL
#define GLOBAL_CLK_LVDS1X_STATUS_drdy                                0x0110000000000104ULL
#define GLOBAL_CLK_LVDS1X_STATUS_locked                              0x0111000000000104ULL
#define GLOBAL_CLK_LVDS1X_STATUS_clkinstopped                        0x0112000000000104ULL
#define GLOBAL_CLK_LVDS1X_STATUS_clkfbstopped                        0x0113000000000104ULL
#define GLOBAL_CLK_LVDS1X_STATUS_output_freq_ctr                     0x0c14000000000104ULL

//
// Register:    GLOBAL_CLK_LVDS4X_CFG
// Description: LVDS 4x MMCM control
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     din                            16  15:00 RW   0x0         MMCM DRP port data in
//     daddr                          7   22:16 RW   0x0         MMCM DRP port address
//     dwe                            1      23 RW   0x0         MMCM DRP port write enable
//     den                            1      24 RW   0x0         MMCM DRP port enable (0 to 1 transition triggers a DRP port
//                                                               read or write operation)
//     rst                            1      25 RO   0x0         Reports reset status for this MMCM. This bit would
//                                                               ordinarily be read/write, but LVDS4X MMCM reset is driven by
//                                                               a state machine controlled by GLOBAL_CLK_LVDS1X_CFG_rst.
//
#define GLOBAL_CLK_LVDS4X_CFG                                        0x0000000000000110ULL
#define GLOBAL_CLK_LVDS4X_CFG_din                                    0x1000000000000110ULL
#define GLOBAL_CLK_LVDS4X_CFG_daddr                                  0x0710000000000110ULL
#define GLOBAL_CLK_LVDS4X_CFG_dwe                                    0x0117000000000110ULL
#define GLOBAL_CLK_LVDS4X_CFG_den                                    0x0118000000000110ULL
#define GLOBAL_CLK_LVDS4X_CFG_rst                                    0x0119000000000110ULL

//
// Register:    GLOBAL_CLK_LVDS4X_STATUS
// Description: LVDS 4x MMCM status
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     dout                           16  15:00 RO   0x0         MMCM DRP port data out
//     drdy                           1      16 RW1C 0x0         MMCM DRP port ready. Latched, write 1 to clear. Goes high to
//                                                               acknowledge a successful DRP port read or write.
//     locked                         1      17 RO   0x0         MMCM locked status.
//     clkinstopped                   1      18 RW1C 0x0         MMCM clock input stopped. Latched, write 1 to clear.
//     clkfbstopped                   1      19 RW1C 0x0         MMCM feedback clock stopped. Latched, write 1 to clear.
//     output_freq_ctr                12  31:20 RO   0x0         Output frequency counter. Divide value by 2.5 to compute
//                                                               LVDS4X clock frequency in MHz.
//
#define GLOBAL_CLK_LVDS4X_STATUS                                     0x0000000000000114ULL
#define GLOBAL_CLK_LVDS4X_STATUS_dout                                0x1000000000000114ULL
#define GLOBAL_CLK_LVDS4X_STATUS_drdy                                0x0110000000000114ULL
#define GLOBAL_CLK_LVDS4X_STATUS_locked                              0x0111000000000114ULL
#define GLOBAL_CLK_LVDS4X_STATUS_clkinstopped                        0x0112000000000114ULL
#define GLOBAL_CLK_LVDS4X_STATUS_clkfbstopped                        0x0113000000000114ULL
#define GLOBAL_CLK_LVDS4X_STATUS_output_freq_ctr                     0x0c14000000000114ULL

//
// Register:    GLOBAL_CLK_CHIPIF_CFG
// Description: High Speed MMCM control
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     din                            16  15:00 RW   0x0         MMCM DRP port data in
//     daddr                          7   22:16 RW   0x0         MMCM DRP port address
//     dwe                            1      23 RW   0x0         MMCM DRP port write enable
//     den                            1      24 RW   0x0         MMCM DRP port enable (0 to 1 transition triggers a DRP port
//                                                               read or write operation)
//     rst                            1      25 RW   0x0         While 1, MMCM is in reset. MMCM should be held in reset
//                                                               while reconfiguring via DRP.
//
#define GLOBAL_CLK_CHIPIF_CFG                                        0x0000000000000150ULL
#define GLOBAL_CLK_CHIPIF_CFG_din                                    0x1000000000000150ULL
#define GLOBAL_CLK_CHIPIF_CFG_daddr                                  0x0710000000000150ULL
#define GLOBAL_CLK_CHIPIF_CFG_dwe                                    0x0117000000000150ULL
#define GLOBAL_CLK_CHIPIF_CFG_den                                    0x0118000000000150ULL
#define GLOBAL_CLK_CHIPIF_CFG_rst                                    0x0119000000000150ULL

//
// Register:    GLOBAL_CLK_CHIPIF_STATUS
// Description: High Speed MMCM status
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     dout                           16  15:00 RO   0x0         MMCM DRP port data out
//     drdy                           1      16 RW1C 0x0         MMCM DRP port ready. Latched, write 1 to clear. Goes high to
//                                                               acknowledge a successful DRP port read or write.
//     locked                         1      17 RO   0x0         MMCM locked status.
//     clkinstopped                   1      18 RW1C 0x0         MMCM clock input stopped. Latched, write 1 to clear.
//     clkfbstopped                   1      19 RW1C 0x0         MMCM feedback clock stopped. Latched, write 1 to clear.
//     output_freq_ctr                12  31:20 RO   0x0         Output frequency counter. Divide value by 10.0 to compute
//                                                               CHIPIF clock frequency in MHz.
//
#define GLOBAL_CLK_CHIPIF_STATUS                                     0x0000000000000154ULL
#define GLOBAL_CLK_CHIPIF_STATUS_dout                                0x1000000000000154ULL
#define GLOBAL_CLK_CHIPIF_STATUS_drdy                                0x0110000000000154ULL
#define GLOBAL_CLK_CHIPIF_STATUS_locked                              0x0111000000000154ULL
#define GLOBAL_CLK_CHIPIF_STATUS_clkinstopped                        0x0112000000000154ULL
#define GLOBAL_CLK_CHIPIF_STATUS_clkfbstopped                        0x0113000000000154ULL
#define GLOBAL_CLK_CHIPIF_STATUS_output_freq_ctr                     0x0c14000000000154ULL

//
// Register:    GLOBAL_RESET_CFG
// Description: Soft reset configuration register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     fpga_softreset                 1       0 RW   0x0         Rising edge of this bit performs a reset of DP, LVDS, PER
//                                                               and CHIPIF blocks (but not GLOBAL or DDR)
//     board_reset                    1       1 RW   0x0         Set to 1 to assert NASCAR board level reset signal
//
#define GLOBAL_RESET_CFG                                             0x0000000000000200ULL
#define GLOBAL_RESET_CFG_fpga_softreset                              0x0100000000000200ULL
#define GLOBAL_RESET_CFG_board_reset                                 0x0101000000000200ULL

//
// Register:    GLOBAL_RESET_STATUS
// Description: Soft reset status register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     fpga_softreset_done            1       0 RW1C 0x0         1 if FPGA soft reset happened since the last time this bit
//                                                               was cleared. Write 1 to clear.
//
#define GLOBAL_RESET_STATUS                                          0x0000000000000204ULL
#define GLOBAL_RESET_STATUS_fpga_softreset_done                      0x0100000000000204ULL

//
// Register:    GLOBAL_DDR_CTL
// Description: DDR control register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     ddr_core_reset                 1       0 RW   0x1         Reset the entire DDR core complex
//     ddr0_reset                     1       1 RW   0x1         DDR controller 0 reset
//     ddr1_reset                     1       2 RW   0x1         DDR controller 1 reset
//
#define GLOBAL_DDR_CTL                                               0x0000000000000300ULL
#define GLOBAL_DDR_CTL_ddr_core_reset                                0x0100000000000300ULL
#define GLOBAL_DDR_CTL_ddr0_reset                                    0x0101000000000300ULL
#define GLOBAL_DDR_CTL_ddr1_reset                                    0x0102000000000300ULL

//
// Register:    GLOBAL_DDR_STATUS
// Description: DDR status register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     ddr0_cal_done                  1       0 RO   0x0         DDR controller 0 calibration done
//     ddr1_cal_done                  1       1 RO   0x0         DDR controller 1 calibration done
//     ddr0_busy                      1       8 RO   0x0         DDR controller 0 is busy
//     ddr1_busy                      1       9 RO   0x0         DDR controller 1 is busy
//
#define GLOBAL_DDR_STATUS                                            0x0000000000000304ULL
#define GLOBAL_DDR_STATUS_ddr0_cal_done                              0x0100000000000304ULL
#define GLOBAL_DDR_STATUS_ddr1_cal_done                              0x0101000000000304ULL
#define GLOBAL_DDR_STATUS_ddr0_busy                                  0x0108000000000304ULL
#define GLOBAL_DDR_STATUS_ddr1_busy                                  0x0109000000000304ULL

//
// Register:    GLOBAL_MODE_CTL
// Description: Global Mode Control register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     compress_en                    1       0 RW   0x0         Compression enable : Write 1 to this bit to enable
//                                                               compression.
//     compression_type               2   02:01 RW   0x0         Compression type. 00: 8-bit representation of cell's value
//                                                               (no bits are cut) 01: 7-bit representation of cell's value
//                                                               (bit 0 is cut) 10: 6-bit representation of cell's value
//                                                               (bits 0 and 1 are cut) 11: 5-bit representation of cell's
//                                                               value (bits 0,1 and 2 are cut)
//     four_gpu_en                    1       3 RW   0x0         Enable Four GPU mode
//
#define GLOBAL_MODE_CTL                                              0x0000000000000500ULL
#define GLOBAL_MODE_CTL_compress_en                                  0x0100000000000500ULL
#define GLOBAL_MODE_CTL_compression_type                             0x0201000000000500ULL
#define GLOBAL_MODE_CTL_four_gpu_en                                  0x0103000000000500ULL

//
// Register:    PER_FLUIDIC_CTL
// Description: Fluidics Control Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     asv_solnd_ctl                  5   04:00 RW   0x0         Anti-siphon solenoid valve control for drive channels
//     wpump1_en                      1       5 RW   0x0         Waste pump1 enable
//     wpump2_en                      1       6 RW   0x0         Waste pump2 enable
//     wpump1_cnt_en                  1       7 RW   0x0         Waste pump1 counter enable
//     wpump2_cnt_en                  1       8 RW   0x0         Waste pump2 counter enable
//
#define PER_FLUIDIC_CTL                                              0x0000000000001020ULL
#define PER_FLUIDIC_CTL_asv_solnd_ctl                                0x0500000000001020ULL
#define PER_FLUIDIC_CTL_wpump1_en                                    0x0105000000001020ULL
#define PER_FLUIDIC_CTL_wpump2_en                                    0x0106000000001020ULL
#define PER_FLUIDIC_CTL_wpump1_cnt_en                                0x0107000000001020ULL
#define PER_FLUIDIC_CTL_wpump2_cnt_en                                0x0108000000001020ULL

//
// Register:    PER_WPUMP_CNT
// Description: Waste Pump Control Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     wpump1_cnt                     16  15:00 RO   0x0         Counter for reporting all of the tachometer edges seen on
//                                                               waste pump1
//     wpump2_cnt                     16  31:16 RO   0x0         Counter for reporting all of the tachometer edges seen on
//                                                               waste pump2
//
#define PER_WPUMP_CNT                                                0x0000000000001024ULL
#define PER_WPUMP_CNT_wpump1_cnt                                     0x1000000000001024ULL
#define PER_WPUMP_CNT_wpump2_cnt                                     0x1010000000001024ULL

//
// Register:    PER_FLUIDIC_STATUS
// Description: Fluidics status Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     asv_solnd_status               1       0 RW1C 0x0         Anti-siphon solenoid valve status. 1: Fault 0: No fault
//                                                               Sticky, write 1 to clear.
//     wpump1_cnt_wrap                1       1 RW1C 0x0         Waste pump1 counter wrapped. Sticky, write 1 to clear.
//     wpump2_cnt_wrap                1       2 RW1C 0x0         Waste pump2 counter wrapped. Sticky, write 1 to clear.
//
#define PER_FLUIDIC_STATUS                                           0x0000000000001028ULL
#define PER_FLUIDIC_STATUS_asv_solnd_status                          0x0100000000001028ULL
#define PER_FLUIDIC_STATUS_wpump1_cnt_wrap                           0x0101000000001028ULL
#define PER_FLUIDIC_STATUS_wpump2_cnt_wrap                           0x0102000000001028ULL

//
// Register:    PER_SENSOR_CTL1
// Description: Sensor control Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     sensor0_obs_time               10  09:00 RW   0x64        Sensor input signal observation time
//     sensor1_obs_time               10  19:10 RW   0x64        Sensor input signal observation time
//     sensor2_obs_time               10  29:20 RW   0x64        Sensor input signal observation time
//
#define PER_SENSOR_CTL1                                              0x000000000000102cULL
#define PER_SENSOR_CTL1_sensor0_obs_time                             0x0a0000000000102cULL
#define PER_SENSOR_CTL1_sensor1_obs_time                             0x0a0a00000000102cULL
#define PER_SENSOR_CTL1_sensor2_obs_time                             0x0a1400000000102cULL

//
// Register:    PER_SENSOR_CTL2
// Description: Sensor control Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     sensor3_obs_time               10  09:00 RW   0x64        Sensor input signal observation time
//     sensor4_obs_time               10  19:10 RW   0x64        Sensor input signal observation time
//     sensor5_obs_time               10  29:20 RW   0x64        Sensor input signal observation time
//
#define PER_SENSOR_CTL2                                              0x0000000000001030ULL
#define PER_SENSOR_CTL2_sensor3_obs_time                             0x0a00000000001030ULL
#define PER_SENSOR_CTL2_sensor4_obs_time                             0x0a0a000000001030ULL
#define PER_SENSOR_CTL2_sensor5_obs_time                             0x0a14000000001030ULL

//
// Register:    PER_SENSOR_CTL3
// Description: Sensor control Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     sensor6_obs_time               10  09:00 RW   0x64        Sensor input signal observation time
//     sensor7_obs_time               10  19:10 RW   0x64        Sensor input signal observation time
//     sensor8_obs_time               10  29:20 RW   0x64        Sensor input signal observation time
//
#define PER_SENSOR_CTL3                                              0x0000000000001034ULL
#define PER_SENSOR_CTL3_sensor6_obs_time                             0x0a00000000001034ULL
#define PER_SENSOR_CTL3_sensor7_obs_time                             0x0a0a000000001034ULL
#define PER_SENSOR_CTL3_sensor8_obs_time                             0x0a14000000001034ULL

//
// Register:    PER_SENSOR_CTL4
// Description: Sensor control Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     sensor0_pol                    1       0 RW   0x0         Sensor input signal polarity
//     sensor1_pol                    1       1 RW   0x0         Sensor input signal polarity
//     sensor2_pol                    1       2 RW   0x0         Sensor input signal polarity
//     sensor3_pol                    1       3 RW   0x0         Sensor input signal polarity
//     sensor4_pol                    1       4 RW   0x0         Sensor input signal polarity
//     sensor5_pol                    1       5 RW   0x0         Sensor input signal polarity
//     sensor6_pol                    1       6 RW   0x0         Sensor input signal polarity
//     sensor7_pol                    1       7 RW   0x0         Sensor input signal polarity
//     sensor8_pol                    1       8 RW   0x0         Sensor input signal polarity
//     sensor0_clr                    1       9 RW   0x0         Sensor observation counter clear. Write 1 to clear
//                                                               observation counter, followed by write 0.
//     sensor1_clr                    1      10 RW   0x0         Sensor observation counter clear. Write 1 to clear
//                                                               observation counter, followed by write 0.
//     sensor2_clr                    1      11 RW   0x0         Sensor observation counter clear. Write 1 to clear
//                                                               observation counter, followed by write 0.
//     sensor3_clr                    1      12 RW   0x0         Sensor observation counter clear. Write 1 to clear
//                                                               observation counter, followed by write 0.
//     sensor4_clr                    1      13 RW   0x0         Sensor observation counter clear. Write 1 to clear
//                                                               observation counter, followed by write 0.
//     sensor5_clr                    1      14 RW   0x0         Sensor observation counter clear. Write 1 to clear
//                                                               observation counter, followed by write 0.
//     sensor6_clr                    1      15 RW   0x0         Sensor observation counter clear. Write 1 to clear
//                                                               observation counter, followed by write 0.
//     sensor7_clr                    1      16 RW   0x0         Sensor observation counter clear. Write 1 to clear
//                                                               observation counter, followed by write 0.
//     sensor8_clr                    1      17 RW   0x0         Sensor observation counter clear. Write 1 to clear
//                                                               observation counter, followed by write 0.
//     sensorcd_clr                   1      18 RW   0x0         Consumable Device (CD) sensor observation counter clear.
//                                                               Write 1 to clear observation counter, followed by write 0.
//     sensorcd_obs_time              10  28:19 RW   0x64        Consumable Device (CD) sensor input signal observation time
//
#define PER_SENSOR_CTL4                                              0x0000000000001038ULL
#define PER_SENSOR_CTL4_sensor0_pol                                  0x0100000000001038ULL
#define PER_SENSOR_CTL4_sensor1_pol                                  0x0101000000001038ULL
#define PER_SENSOR_CTL4_sensor2_pol                                  0x0102000000001038ULL
#define PER_SENSOR_CTL4_sensor3_pol                                  0x0103000000001038ULL
#define PER_SENSOR_CTL4_sensor4_pol                                  0x0104000000001038ULL
#define PER_SENSOR_CTL4_sensor5_pol                                  0x0105000000001038ULL
#define PER_SENSOR_CTL4_sensor6_pol                                  0x0106000000001038ULL
#define PER_SENSOR_CTL4_sensor7_pol                                  0x0107000000001038ULL
#define PER_SENSOR_CTL4_sensor8_pol                                  0x0108000000001038ULL
#define PER_SENSOR_CTL4_sensor0_clr                                  0x0109000000001038ULL
#define PER_SENSOR_CTL4_sensor1_clr                                  0x010a000000001038ULL
#define PER_SENSOR_CTL4_sensor2_clr                                  0x010b000000001038ULL
#define PER_SENSOR_CTL4_sensor3_clr                                  0x010c000000001038ULL
#define PER_SENSOR_CTL4_sensor4_clr                                  0x010d000000001038ULL
#define PER_SENSOR_CTL4_sensor5_clr                                  0x010e000000001038ULL
#define PER_SENSOR_CTL4_sensor6_clr                                  0x010f000000001038ULL
#define PER_SENSOR_CTL4_sensor7_clr                                  0x0110000000001038ULL
#define PER_SENSOR_CTL4_sensor8_clr                                  0x0111000000001038ULL
#define PER_SENSOR_CTL4_sensorcd_clr                                 0x0112000000001038ULL
#define PER_SENSOR_CTL4_sensorcd_obs_time                            0x0a13000000001038ULL

//
// Register:    PER_SENSOR_STATUS
// Description: Fluidics status Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     sensor0                        1       0 RW1C 0x0         Sensor status. Sticky, write 1 to clear.
//     sensor1                        1       1 RW1C 0x0         Sensor status. Sticky, write 1 to clear.
//     sensor2                        1       2 RW1C 0x0         Sensor status. Sticky, write 1 to clear.
//     sensor3                        1       3 RW1C 0x0         Sensor status. Sticky, write 1 to clear.
//     sensor4                        1       4 RW1C 0x0         Sensor status. Sticky, write 1 to clear.
//     sensor5                        1       5 RW1C 0x0         Sensor status. Sticky, write 1 to clear.
//     sensor6                        1       6 RW1C 0x0         Sensor status. Sticky, write 1 to clear.
//     sensor7                        1       7 RW1C 0x0         Sensor status. Sticky, write 1 to clear.
//     sensor8                        1       8 RW1C 0x0         Sensor status. Sticky, write 1 to clear.
//     sensorcd                       1       9 RW1C 0x0         Consumable Device (CD) sensor status. Sticky, write 1 to
//                                                               clear.
//
#define PER_SENSOR_STATUS                                            0x000000000000103cULL
#define PER_SENSOR_STATUS_sensor0                                    0x010000000000103cULL
#define PER_SENSOR_STATUS_sensor1                                    0x010100000000103cULL
#define PER_SENSOR_STATUS_sensor2                                    0x010200000000103cULL
#define PER_SENSOR_STATUS_sensor3                                    0x010300000000103cULL
#define PER_SENSOR_STATUS_sensor4                                    0x010400000000103cULL
#define PER_SENSOR_STATUS_sensor5                                    0x010500000000103cULL
#define PER_SENSOR_STATUS_sensor6                                    0x010600000000103cULL
#define PER_SENSOR_STATUS_sensor7                                    0x010700000000103cULL
#define PER_SENSOR_STATUS_sensor8                                    0x010800000000103cULL
#define PER_SENSOR_STATUS_sensorcd                                   0x010900000000103cULL

//
// Register:    PER_PWR_CTL1
// Description: Power control 1 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     pwr_sensor_on                  1       0 RW   0x0         Turn on power to sensor on the rising edge of this register.
//                                                               Turn off power to sensor when this register is zero.
//                                                               Automatically sequences the voltage rails according to
//                                                               sensor chip requirements. Individual voltage rail control is
//                                                               typically not required. This bit should be set to zero when
//                                                               per_expert_ctl1.pwr_manual_ctl=1
//     pwr_otp_prog                   1       1 RW   0x0         When one, the OTP voltage switch is set to the programming
//                                                               voltage. Requires sensor power to be on or
//                                                               per_expert_ctl1.pwr_manual_ctl=1
//     vdd_io_en                      1       2 RW   0x0         Turn on VDD_IO. Requires per_expert_ctl1.pwr_manual_ctl=1
//     vdd_en                         1       3 RW   0x0         Manually turn on VDD. Requires
//                                                               per_expert_ctl1.pwr_manual_ctl=1
//     avdd_en                        1       4 RW   0x0         Manually turn on AVDD. Requires
//                                                               per_expert_ctl1.pwr_manual_ctl=1
//     vdd_lvds_en                    1       5 RW   0x0         Manually turn on VDD_LVDS. Requires
//                                                               per_expert_ctl1.pwr_manual_ctl=1
//     lvds_clk_oe                    1       7 RW   0x0         Manually turn on the LVDS clock output enable. Requires
//                                                               per_expert_ctl1.pwr_manual_ctl=1
//     pwr_1p9v_sel                   1       8 RW   0x0         When one, the sensor chip voltage will be 1.9V instead of
//                                                               1.8V. Set this to the desired value before turning on power
//                                                               to the chip.
//     ignore_clamp                   1       9 RW   0x0         When 1, the disconnected state of CD engagement sensor will
//                                                               be ignored for power OFF conditions
//
#define PER_PWR_CTL1                                                 0x0000000000001040ULL
#define PER_PWR_CTL1_pwr_sensor_on                                   0x0100000000001040ULL
#define PER_PWR_CTL1_pwr_otp_prog                                    0x0101000000001040ULL
#define PER_PWR_CTL1_vdd_io_en                                       0x0102000000001040ULL
#define PER_PWR_CTL1_vdd_en                                          0x0103000000001040ULL
#define PER_PWR_CTL1_avdd_en                                         0x0104000000001040ULL
#define PER_PWR_CTL1_vdd_lvds_en                                     0x0105000000001040ULL
#define PER_PWR_CTL1_lvds_clk_oe                                     0x0107000000001040ULL
#define PER_PWR_CTL1_pwr_1p9v_sel                                    0x0108000000001040ULL
#define PER_PWR_CTL1_ignore_clamp                                    0x0109000000001040ULL

//
// Register:    PER_PWR_STATUS1
// Description: Power Status 1 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     pwr_sensor_on                  1       0 RO   0x0         The sensor power is fully on. This bit only gets set when
//                                                               the per_pwr_ctl1.pwr_sensor_on sequence has completed.
//     pwr_otp_prog                   1       1 RO   0x0         OTP programming voltage is selected.
//     vdd_io_en                      1       2 RO   0x0         VDD_IO is on.
//     vdd_en                         1       3 RO   0x0         VDD is on.
//     avdd_en                        1       4 RO   0x0         AVDD is on.
//     vdd_lvds_en                    1       5 RO   0x0         VDD_LVDS is on.
//     lvds_clk_oe                    1       7 RO   0x0         LVDS clock output enable is on.
//     pwr_sensor_off                 1       8 RO   0x1         The sensor power is fully off
//     detect_chip_n                  1       9 RO   0x1         When zero, a sensor chip is detected.
//     detect_8m_n                    1      10 RO   0x1         When zero, the Seqall 8M chip is detected.
//     detect_128k_n                  1      11 RO   0x1         When zero, the 128K sensor chip is detected. This FPGA does
//                                                               not support the 128K sensor.
//
#define PER_PWR_STATUS1                                              0x0000000000001044ULL
#define PER_PWR_STATUS1_pwr_sensor_on                                0x0100000000001044ULL
#define PER_PWR_STATUS1_pwr_otp_prog                                 0x0101000000001044ULL
#define PER_PWR_STATUS1_vdd_io_en                                    0x0102000000001044ULL
#define PER_PWR_STATUS1_vdd_en                                       0x0103000000001044ULL
#define PER_PWR_STATUS1_avdd_en                                      0x0104000000001044ULL
#define PER_PWR_STATUS1_vdd_lvds_en                                  0x0105000000001044ULL
#define PER_PWR_STATUS1_lvds_clk_oe                                  0x0107000000001044ULL
#define PER_PWR_STATUS1_pwr_sensor_off                               0x0108000000001044ULL
#define PER_PWR_STATUS1_detect_chip_n                                0x0109000000001044ULL
#define PER_PWR_STATUS1_detect_8m_n                                  0x010a000000001044ULL
#define PER_PWR_STATUS1_detect_128k_n                                0x010b000000001044ULL

//
// Register:    PER_IO_CTL1
// Description: IO Control 1 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     gpio15_dir_f2c                 1       0 RW   0x0         Select the direction of the sensor chip GPIO15. When one,
//                                                               the FPGA outputs data to sensor GPIO15.
//     gpio_ls_oe                     1       2 RW   0x0         Enable the outputs of the level shifters between the FPGA
//                                                               and the sensor chip.
//     pellet_gnd                     1       3 RW   0x0         When one, the pellet is grounded.
//     res_meas                       1       4 RW   0x0         Resistance measurement enable
//
#define PER_IO_CTL1                                                  0x0000000000001048ULL
#define PER_IO_CTL1_gpio15_dir_f2c                                   0x0100000000001048ULL
#define PER_IO_CTL1_gpio_ls_oe                                       0x0102000000001048ULL
#define PER_IO_CTL1_pellet_gnd                                       0x0103000000001048ULL
#define PER_IO_CTL1_res_meas                                         0x0104000000001048ULL

//
// Register:    PER_IO_STATUS1
// Description: I/O status 1 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     fan_tach                       9   08:00 RO   0x0         Instantaneous value of the fan tach input pins. Bit 0 is the
//                                                               FPGA fan, bits 1-8 are the FAN1 to FAN8 headers.
//
#define PER_IO_STATUS1                                               0x000000000000104cULL
#define PER_IO_STATUS1_fan_tach                                      0x090000000000104cULL

//
// Register:    PER_EXPERT_CTL1
// Description: Expert control 1 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     pwr_manual_ctl                 1       0 RW   0x0         Manual power control. It is only safe to change the value of
//                                                               this bit when all voltage rails are off.
//     pwr_ignore_unplug              1       1 RW   0x0         In manual power control mode, also ignore sensor unplug.
//
#define PER_EXPERT_CTL1                                              0x0000000000001050ULL
#define PER_EXPERT_CTL1_pwr_manual_ctl                               0x0100000000001050ULL
#define PER_EXPERT_CTL1_pwr_ignore_unplug                            0x0101000000001050ULL

//
// Register:    PER_FAN_PWM_CTL1
// Description: Fan PWM control 1 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     fan0_duty_cycle                8   07:00 RW   0x7f        Fan0 duty cycle
//     fan1_duty_cycle                8   15:08 RW   0x7f        Fan1 duty cycle
//     fan2_duty_cycle                8   23:16 RW   0x7f        Fan2 duty cycle
//     fan3_duty_cycle                8   31:24 RW   0x7f        Fan3 duty cycle
//
#define PER_FAN_PWM_CTL1                                             0x0000000000001054ULL
#define PER_FAN_PWM_CTL1_fan0_duty_cycle                             0x0800000000001054ULL
#define PER_FAN_PWM_CTL1_fan1_duty_cycle                             0x0808000000001054ULL
#define PER_FAN_PWM_CTL1_fan2_duty_cycle                             0x0810000000001054ULL
#define PER_FAN_PWM_CTL1_fan3_duty_cycle                             0x0818000000001054ULL

//
// Register:    PER_FAN_PWM_CTL2
// Description: Fan PWM control 2 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     fan4_duty_cycle                8   07:00 RW   0x7f        Fan4 duty cycle
//     fan5_duty_cycle                8   15:08 RW   0x7f        Fan5 duty cycle
//     fan6_duty_cycle                8   23:16 RW   0x7f        Fan6 duty cycle
//     fan7_duty_cycle                8   31:24 RW   0x7f        Fan7 duty cycle
//
#define PER_FAN_PWM_CTL2                                             0x0000000000001058ULL
#define PER_FAN_PWM_CTL2_fan4_duty_cycle                             0x0800000000001058ULL
#define PER_FAN_PWM_CTL2_fan5_duty_cycle                             0x0808000000001058ULL
#define PER_FAN_PWM_CTL2_fan6_duty_cycle                             0x0810000000001058ULL
#define PER_FAN_PWM_CTL2_fan7_duty_cycle                             0x0818000000001058ULL

//
// Register:    PER_FAN_PWM_CTL3
// Description: Fan PWM control 3 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     fan0_100p_duty_cycle           1       0 RW   0x1         Fan0 100% duty cycle
//     fan1_100p_duty_cycle           1       1 RW   0x1         Fan1 100% duty cycle
//     fan2_100p_duty_cycle           1       2 RW   0x1         Fan2 100% duty cycle
//     fan3_100p_duty_cycle           1       3 RW   0x1         Fan3 100% duty cycle
//     fan4_100p_duty_cycle           1       4 RW   0x1         Fan4 100% duty cycle
//     fan5_100p_duty_cycle           1       5 RW   0x1         Fan5 100% duty cycle
//     fan6_100p_duty_cycle           1       6 RW   0x1         Fan6 100% duty cycle
//     fan7_100p_duty_cycle           1       7 RW   0x1         Fan7 100% duty cycle
//
#define PER_FAN_PWM_CTL3                                             0x000000000000105cULL
#define PER_FAN_PWM_CTL3_fan0_100p_duty_cycle                        0x010000000000105cULL
#define PER_FAN_PWM_CTL3_fan1_100p_duty_cycle                        0x010100000000105cULL
#define PER_FAN_PWM_CTL3_fan2_100p_duty_cycle                        0x010200000000105cULL
#define PER_FAN_PWM_CTL3_fan3_100p_duty_cycle                        0x010300000000105cULL
#define PER_FAN_PWM_CTL3_fan4_100p_duty_cycle                        0x010400000000105cULL
#define PER_FAN_PWM_CTL3_fan5_100p_duty_cycle                        0x010500000000105cULL
#define PER_FAN_PWM_CTL3_fan6_100p_duty_cycle                        0x010600000000105cULL
#define PER_FAN_PWM_CTL3_fan7_100p_duty_cycle                        0x010700000000105cULL

//
// Register:    PER_FAN0_STATUS1
// Description: Fan 0 status 1 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     cnt                            16  15:00 RO   0x0         Count of the fan tach rising edges per second
//
#define PER_FAN0_STATUS1                                             0x0000000000001060ULL
#define PER_FAN0_STATUS1_cnt                                         0x1000000000001060ULL

//
// Register:    PER_FAN1_STATUS1
// Description: Fan 1 status 1 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     cnt                            16  15:00 RO   0x0         Count of the fan tach rising edges per second
//
#define PER_FAN1_STATUS1                                             0x0000000000001064ULL
#define PER_FAN1_STATUS1_cnt                                         0x1000000000001064ULL

//
// Register:    PER_FAN2_STATUS1
// Description: Fan 2 status 1 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     cnt                            16  15:00 RO   0x0         Count of the fan tach rising edges per second
//
#define PER_FAN2_STATUS1                                             0x0000000000001068ULL
#define PER_FAN2_STATUS1_cnt                                         0x1000000000001068ULL

//
// Register:    PER_FAN3_STATUS1
// Description: Fan 3 status 1 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     cnt                            16  15:00 RO   0x0         Count of the fan tach rising edges per second
//
#define PER_FAN3_STATUS1                                             0x000000000000106cULL
#define PER_FAN3_STATUS1_cnt                                         0x100000000000106cULL

//
// Register:    PER_FAN4_STATUS1
// Description: Fan 4 status 1 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     cnt                            16  15:00 RO   0x0         Count of the fan tach rising edges per second
//
#define PER_FAN4_STATUS1                                             0x0000000000001070ULL
#define PER_FAN4_STATUS1_cnt                                         0x1000000000001070ULL

//
// Register:    PER_FAN5_STATUS1
// Description: Fan 5 status 1 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     cnt                            16  15:00 RO   0x0         Count of the fan tach rising edges per second
//
#define PER_FAN5_STATUS1                                             0x0000000000001074ULL
#define PER_FAN5_STATUS1_cnt                                         0x1000000000001074ULL

//
// Register:    PER_FAN6_STATUS1
// Description: Fan 6 status 1 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     cnt                            16  15:00 RO   0x0         Count of the fan tach rising edges per second
//
#define PER_FAN6_STATUS1                                             0x0000000000001078ULL
#define PER_FAN6_STATUS1_cnt                                         0x1000000000001078ULL

//
// Register:    PER_FAN7_STATUS1
// Description: Fan 7 status 1 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     cnt                            16  15:00 RO   0x0         Count of the fan tach rising edges per second
//
#define PER_FAN7_STATUS1                                             0x000000000000107cULL
#define PER_FAN7_STATUS1_cnt                                         0x100000000000107cULL

//
// Register:    PER_FAN8_STATUS1
// Description: Fan 8 status 1 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     cnt                            16  15:00 RO   0x0         Count of the fan tach rising edges per second
//
#define PER_FAN8_STATUS1                                             0x0000000000001080ULL
#define PER_FAN8_STATUS1_cnt                                         0x1000000000001080ULL

//
// Register:    PER_EEPROM_CMD
// Description: EEPROM command, address Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     valid                          1       0 RW1S 0x0         Command valid. Set by SW. Cleared by HW.
//     rdwr                           1       1 RW   0x0         Command: Read=1, Write=0
//     addr                           9   10:02 RW   0x0         Command address A8:A0
//
#define PER_EEPROM_CMD                                               0x0000000000001090ULL
#define PER_EEPROM_CMD_valid                                         0x0100000000001090ULL
#define PER_EEPROM_CMD_rdwr                                          0x0101000000001090ULL
#define PER_EEPROM_CMD_addr                                          0x0902000000001090ULL

//
// Register:    PER_EEPROM_WDATA
// Description: EEPROM Write data Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RW   0x0         Write data
//
#define PER_EEPROM_WDATA                                             0x0000000000001094ULL
#define PER_EEPROM_WDATA_data                                        0x2000000000001094ULL

//
// Register:    PER_EEPROM_RDATA
// Description: EEPROM Read data Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RO   0x0         Read data
//
#define PER_EEPROM_RDATA                                             0x0000000000001098ULL
#define PER_EEPROM_RDATA_data                                        0x2000000000001098ULL

//
// Register:    PER_EEPROM_STATUS
// Description: EEPROM status Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     done                           1       0 RW1C 0x0         Command Completed/Read data ready, Write 1 to clear.
//     not_responding                 1       1 RW1C 0x0         EEPROM failed to respond to an I2C command since the last
//                                                               time the error bit was cleared. Write 1 to clear.
//     wr_page_cross_error            1       2 RW1C 0x0         Write page cross error, Write 1 to clear.
//
#define PER_EEPROM_STATUS                                            0x000000000000109cULL
#define PER_EEPROM_STATUS_done                                       0x010000000000109cULL
#define PER_EEPROM_STATUS_not_responding                             0x010100000000109cULL
#define PER_EEPROM_STATUS_wr_page_cross_error                        0x010200000000109cULL

//
// Register:    PER_I2C_TMP_CFG1
// Description: PER I2C Temperature Config 1 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     thigh                          16  15:00 RW   0x3e8       I2C SCL high time in 200MHz clock cycles. Maximum SCL speed
//                                                               is 100KHz. Default: 1000 cycles = 5us high time.
//     tlow                           16  31:16 RW   0x3de       I2C SCL low time in 200MHz clock cycles (total SCL low time
//                                                               is this field plus the value of thold). Default: 990 cycles
//                                                               + 10 cycles Thold = 1000 cycles = 5us low time.
//
#define PER_I2C_TMP_CFG1                                             0x00000000000010a0ULL
#define PER_I2C_TMP_CFG1_thigh                                       0x10000000000010a0ULL
#define PER_I2C_TMP_CFG1_tlow                                        0x10100000000010a0ULL

//
// Register:    PER_I2C_TMP_CFG2
// Description: PER I2C Temperature Config 2 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     thold                          8   07:00 RW   0xa         I2C data hold time in 200MHz clock cycles (SCL low time
//                                                               includes this value). Default: 10 cycles = 50ns.
//     tsp                            5   12:08 RW   0xa         I2C Tsp (worst case spike width) in 200MHz clock cycles.
//                                                               Default: 10 cycles = 50ns (maximum filtering permitted by
//                                                               i2c spec).
//     multimaster_en                 1      13 RW   0x0         Enable multimaster mode.
//     clkstretch_en                  1      14 RW   0x0         Permit I2C devices to stretch the clock.
//     soft_reset                     1      15 RW   0x0         The rising edge of this bit resets the NCT72 reader, EEPROM
//                                                               and I2C controller modules responsible for reading NCT72
//                                                               sensor chips and EEPROM.
//
#define PER_I2C_TMP_CFG2                                             0x00000000000010a4ULL
#define PER_I2C_TMP_CFG2_thold                                       0x08000000000010a4ULL
#define PER_I2C_TMP_CFG2_tsp                                         0x05080000000010a4ULL
#define PER_I2C_TMP_CFG2_multimaster_en                              0x010d0000000010a4ULL
#define PER_I2C_TMP_CFG2_clkstretch_en                               0x010e0000000010a4ULL
#define PER_I2C_TMP_CFG2_soft_reset                                  0x010f0000000010a4ULL

//
// Register:    PER_I2C_TMP_STATUS1
// Description: PER I2C Temperature Status 1 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     i2c_busy                       1       0 RO   0x0         Reads 1 while I2C bus is busy.
//     controller_busy                1       1 RO   0x0         Reads 1 while I2C controller is busy.
//     sda_value                      1       2 RO   0x0         Instantaneous value of the SDA line.
//     scl_value                      1       3 RO   0x0         Instantaneous value of the SCL line.
//
#define PER_I2C_TMP_STATUS1                                          0x00000000000010a8ULL
#define PER_I2C_TMP_STATUS1_i2c_busy                                 0x01000000000010a8ULL
#define PER_I2C_TMP_STATUS1_controller_busy                          0x01010000000010a8ULL
#define PER_I2C_TMP_STATUS1_sda_value                                0x01020000000010a8ULL
#define PER_I2C_TMP_STATUS1_scl_value                                0x01030000000010a8ULL

//
// Register:    PER_I2C_TMP_NCT72_4C
// Description: PER I2C Temperature for Device at Address 4C Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     nct72_chip_not_responding      1       0 RW1C 0x0         Reads 1 if the NCT72 chip at address 0x4C failed to respond
//                                                               to an I2C command since the last time the error bit was
//                                                               cleared. Write 1 to clear.
//     diode_fault_oc                 1       1 RW1C 0x0         Reads 1 if the NCT72 chip at address 0x4C detected that the
//                                                               external diode connection is open circuit since the last
//                                                               time the error bit was cleared. Write 1 to clear.
//     nct72_temp                     8   15:08 RO   0x0         NCT72 internal temperature reading, in degrees C, with an
//                                                               offset of +64C (0x00 = -64C, 0xff = +191C).
//     ext_diode_temp                 10  25:16 RO   0x0         External diode temperature reading, in 8.2 fixed point
//                                                               format, with an offset of +64C (0x000 = -64.00C, 0x3ff =
//                                                               +191.75C).
//
#define PER_I2C_TMP_NCT72_4C                                         0x00000000000010acULL
#define PER_I2C_TMP_NCT72_4C_nct72_chip_not_responding               0x01000000000010acULL
#define PER_I2C_TMP_NCT72_4C_diode_fault_oc                          0x01010000000010acULL
#define PER_I2C_TMP_NCT72_4C_nct72_temp                              0x08080000000010acULL
#define PER_I2C_TMP_NCT72_4C_ext_diode_temp                          0x0a100000000010acULL

//
// Register:    PER_I2C_TMP_NCT72_4D
// Description: PER I2C Temperature for Device at Address 4D Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     nct72_chip_not_responding      1       0 RW1C 0x0         Reads 1 if the NCT72 chip at address 0x4D failed to respond
//                                                               to an I2C command since the last time the error bit was
//                                                               cleared. Write 1 to clear.
//     diode_fault_oc                 1       1 RW1C 0x0         Reads 1 if the NCT72 chip at address 0x4D detected that the
//                                                               external diode connection is open circuit since the last
//                                                               time the error bit was cleared. Write 1 to clear.
//     nct72_temp                     8   15:08 RO   0x0         NCT72 internal temperature reading, in degrees C, with an
//                                                               offset of +64C (0x00 = -64C, 0xff = +191C).
//     ext_diode_temp                 10  25:16 RO   0x0         External diode temperature reading, in 8.2 fixed point
//                                                               format, with an offset of +64C (0x000 = -64.00C, 0x3ff =
//                                                               +191.75C).
//
#define PER_I2C_TMP_NCT72_4D                                         0x00000000000010b0ULL
#define PER_I2C_TMP_NCT72_4D_nct72_chip_not_responding               0x01000000000010b0ULL
#define PER_I2C_TMP_NCT72_4D_diode_fault_oc                          0x01010000000010b0ULL
#define PER_I2C_TMP_NCT72_4D_nct72_temp                              0x08080000000010b0ULL
#define PER_I2C_TMP_NCT72_4D_ext_diode_temp                          0x0a100000000010b0ULL

//
// Register:    PER_TEC_CTL1
// Description: PER TEC Control 1 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     pid_update_period              32  31:00 RW   0x1312d00   Sets PID loop update period in 200 MHz clock cycles. Default
//                                                               value gives 10Hz updates.
//
#define PER_TEC_CTL1                                                 0x00000000000010c0ULL
#define PER_TEC_CTL1_pid_update_period                               0x20000000000010c0ULL

//
// Register:    PER_TEC1_STATUS1
// Description: PER TEC1 Status 1 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     tec_on                         1       0 RO   0x0         Reads 1 while TEC1 is powered up. NOTE: The FPGA will
//                                                               automatically shut TEC power off on any fault. TEC power
//                                                               cannot be restored until all fault bits are cleared and
//                                                               PER_TEC1_CTL1_power_en is cycled to 0 and then 1 again.
//     overcurrent_fault              1       1 RW1C 0x0         Reads 1 if TEC1 drive circuit overcurrent detected since
//                                                               last clear. Write 1 to clear.
//     nct72_4c_fault                 1       2 RO   0x0         Reads 1 while NCT72 sensor reader reports an open circuit or
//                                                               i2c comms failure for sensor 0x4c. Faults are suppressed if
//                                                               NCT72 0x4c is not in use (see PER_TEC1_CTL1_sensor_sel).
//                                                               These errors are reported and cleared in
//                                                               PER_I2C_TMP_NCT72_4C.
//     nct72_4d_fault                 1       3 RO   0x0         Reads 1 while NCT72 sensor reader reports an open circuit or
//                                                               i2c comms failure for sensor 0x4d. Faults are suppressed if
//                                                               NCT72 0x4d is not in use (see PER_TEC1_CTL1_sensor_sel).
//                                                               These errors are reported and cleared in
//                                                               PER_I2C_TMP_NCT72_4D.
//     nct72_4c_temp_range_fault      1       4 RW1C 0x0         Reads 1 if NCT72 0x4c sensor temperature was out of range
//                                                               since last clear (legal range is configured in
//                                                               PER_TEC1_CTL8). Faults are suppressed if NCT72 0x4c is not
//                                                               in use (see PER_TEC1_CTL1_sensor_sel). Write 1 to clear.
//     nct72_4d_temp_range_fault      1       5 RW1C 0x0         Reads 1 if NCT72 0x4d sensor temperature was out of range
//                                                               since last clear (legal range is configured in
//                                                               PER_TEC1_CTL8). Faults are suppressed if NCT72 0x4d is not
//                                                               in use (see PER_TEC1_CTL1_sensor_sel). Write 1 to clear.
//     sensor_unplugged_fault         1       6 RW1C 0x0         Reads 1 if sequencing sensor chip was unplugged since last
//                                                               clear. Write 1 to clear.
//     fan_fault                      1       7 RW1C 0x0         Reads 1 if fan tachometer has been out of range since last
//                                                               clear (legal range is configured in PER_TEC1_CTL11). Write 1
//                                                               to clear.
//     hbridge_dutycycle              12  27:16 RO   0x0         Read to observe the duty cycle selected by PID for the TEC
//                                                               H-Bridge PWM. Scale is 0=-100%, 1000=0%, 2000=+100%.
//
#define PER_TEC1_STATUS1                                             0x00000000000010c8ULL
#define PER_TEC1_STATUS1_tec_on                                      0x01000000000010c8ULL
#define PER_TEC1_STATUS1_overcurrent_fault                           0x01010000000010c8ULL
#define PER_TEC1_STATUS1_nct72_4c_fault                              0x01020000000010c8ULL
#define PER_TEC1_STATUS1_nct72_4d_fault                              0x01030000000010c8ULL
#define PER_TEC1_STATUS1_nct72_4c_temp_range_fault                   0x01040000000010c8ULL
#define PER_TEC1_STATUS1_nct72_4d_temp_range_fault                   0x01050000000010c8ULL
#define PER_TEC1_STATUS1_sensor_unplugged_fault                      0x01060000000010c8ULL
#define PER_TEC1_STATUS1_fan_fault                                   0x01070000000010c8ULL
#define PER_TEC1_STATUS1_hbridge_dutycycle                           0x0c100000000010c8ULL

//
// Register:    PER_TEC1_CTL1
// Description: PER TEC1 Control 1 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     power_en                       1       0 RW   0x0         The rising edge of this bit requests TEC powerup. If powerup
//                                                               is successful, TEC power will stay on until this bit is
//                                                               cleared or a fault occurs. After a powerup attempt, check
//                                                               PER_TEC1_STATUS1_tec_on to determine whether TEC power is
//                                                               actually on. If powerup does not succeed, read the fault
//                                                               bits in PER_TEC1_STATUS1 to determine why.
//     clear_state                    1       1 RW   0x0         The rising edge of this bit clears PID loop integral and
//                                                               derivative error state.
//     sensor_sel                     2   03:02 RW   0x1         Selects which sensors are used as feedback to the TEC1 PID
//                                                               loop. 0=NCT72 @0x4C, 1=NCT72 @0x4D, 2=average of 4C and 4D,
//                                                               3=reserved (do not use). WARNING! If using a B0 chip, or
//                                                               using a NASCAR board, do not select sensor 4C (either by
//                                                               itself or averaged).
//     fan_sel                        4   07:04 RW   0x1         Selects which fan tachometer sensor to use for determining
//                                                               fan fault. 1=FAN1, 2=FAN2, ..., 8=FAN8. Values outside of 1
//                                                               to 8 are undefined, but will select FAN1.
//
#define PER_TEC1_CTL1                                                0x00000000000010ccULL
#define PER_TEC1_CTL1_power_en                                       0x01000000000010ccULL
#define PER_TEC1_CTL1_clear_state                                    0x01010000000010ccULL
#define PER_TEC1_CTL1_sensor_sel                                     0x02020000000010ccULL
#define PER_TEC1_CTL1_fan_sel                                        0x04040000000010ccULL

//
// Register:    PER_TEC1_CTL2
// Description: PER TEC1 Control 2 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     pid_set_point                  18  17:00 RW   0x1640      PID loop set point (degrees C, 12.6 fixed point with 64.0
//                                                               degC offset; default is 25.0 degC)
//
#define PER_TEC1_CTL2                                                0x00000000000010d0ULL
#define PER_TEC1_CTL2_pid_set_point                                  0x12000000000010d0ULL

//
// Register:    PER_TEC1_CTL3
// Description: PER TEC1 Control 3 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     pid_kp                         18  17:00 RW   0x4b00      PID loop P constant (12.6 fixed point)
//
#define PER_TEC1_CTL3                                                0x00000000000010d4ULL
#define PER_TEC1_CTL3_pid_kp                                         0x12000000000010d4ULL

//
// Register:    PER_TEC1_CTL4
// Description: PER TEC1 Control 4 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     pid_ki                         18  17:00 RW   0x100       PID loop I constant (12.6 fixed point)
//
#define PER_TEC1_CTL4                                                0x00000000000010d8ULL
#define PER_TEC1_CTL4_pid_ki                                         0x12000000000010d8ULL

//
// Register:    PER_TEC1_CTL5
// Description: PER TEC1 Control 5 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     pid_i_disable_thresh           18  17:00 RW   0x60        PID loop I disable threshold (12.6 fixed point)
//
#define PER_TEC1_CTL5                                                0x00000000000010dcULL
#define PER_TEC1_CTL5_pid_i_disable_thresh                           0x12000000000010dcULL

//
// Register:    PER_TEC1_CTL6
// Description: PER TEC1 Control 6 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     pid_i_windup_limit             18  17:00 RW   0xa00       Integral windup limit (12.6 fixed point)
//
#define PER_TEC1_CTL6                                                0x00000000000010e0ULL
#define PER_TEC1_CTL6_pid_i_windup_limit                             0x12000000000010e0ULL

//
// Register:    PER_TEC1_CTL7
// Description: PER TEC1 Control 7 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     pid_kd                         18  17:00 RW   0x0         PID loop D constant (12.6 fixed point)
//
#define PER_TEC1_CTL7                                                0x00000000000010e4ULL
#define PER_TEC1_CTL7_pid_kd                                         0x12000000000010e4ULL

//
// Register:    PER_TEC1_CTL8
// Description: PER TEC1 Control 8 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     min_chip_temp                  10  09:00 RW   0xd8        FPGA turns TEC off if chip temperature reads less than this
//                                                               value. 8.2 fixed point with 64C offset; code 0 = -64.00C,
//                                                               1023 = +191.75C
//     max_chip_temp                  10  25:16 RW   0x1f0       FPGA turns TEC off if chip temperature reads greater than
//                                                               this value. 8.2 fixed point with 64C offset; code 0 =
//                                                               -64.00C, 1023 = +191.75C
//
#define PER_TEC1_CTL8                                                0x00000000000010e8ULL
#define PER_TEC1_CTL8_min_chip_temp                                  0x0a000000000010e8ULL
#define PER_TEC1_CTL8_max_chip_temp                                  0x0a100000000010e8ULL

//
// Register:    PER_TEC1_CTL9
// Description: PER TEC1 Control 9 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     pid_control_min                18  17:00 RW   0x7d00      PID control output minimum value (12.6 fixed point). Limit
//                                                               to -95% to prevent damage to FET. Scale is 0.0=-100%,
//                                                               1000.0=0%, 2000.0=+100%.
//
#define PER_TEC1_CTL9                                                0x00000000000010ecULL
#define PER_TEC1_CTL9_pid_control_min                                0x12000000000010ecULL

//
// Register:    PER_TEC1_CTL10
// Description: PER TEC1 Control 10 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     pid_control_max                18  17:00 RW   0x17700     PID control output maximum value (12.6 fixed point). Limit
//                                                               to 95% to prevent damage to FET. Scale is 0.0=-100%,
//                                                               1000.0=0%, 2000.0=+100%.
//
#define PER_TEC1_CTL10                                               0x00000000000010f0ULL
#define PER_TEC1_CTL10_pid_control_max                               0x12000000000010f0ULL

//
// Register:    PER_TEC1_CTL11
// Description: PER TEC1 Control 11 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     fan_tach_min                   16  15:00 RW   0x64        If the TEC fan tachometer reads less than this threshold,
//                                                               safety logic will declare a TEC fan fault and shut off the
//                                                               TEC. Programming this field to 0x0000 disables the min
//                                                               check. The TEC fan tach reading can come from any of the 8
//                                                               fan headers, and is configured in PER_TEC1_CTL1_fan_sel.
//     fan_tach_max                   16  31:16 RW   0xffff      If the TEC fan tachometer reads greater than this threshold,
//                                                               safety logic will declare a TEC fan fault and shut off the
//                                                               TEC. Programming this field to 0xFFFF disables the max
//                                                               check. The TEC fan tach reading can come from any of the 8
//                                                               fan headers, and is configured in PER_TEC1_CTL1_fan_sel.
//
#define PER_TEC1_CTL11                                               0x00000000000010f4ULL
#define PER_TEC1_CTL11_fan_tach_min                                  0x10000000000010f4ULL
#define PER_TEC1_CTL11_fan_tach_max                                  0x10100000000010f4ULL

//
// Register:    PER_LIQI_CTL1
// Description: PER LIQI Control 1 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     capture_depth                  16  15:00 RW   0x2000      Configures the number of LIQI ADC samples to capture into
//                                                               the LIQI        data FIFO each time the running userwave
//                                                               requests a LIQI trace.          NOTE: Values greater than
//                                                               8192 (the size of the LIQI FIFO) are          permitted, but
//                                                               require software to actively drain the FIFO during
//                                                               capture so that it does not overflow.
//     spi_halfcycle                  8   23:16 RW   0xa         Configures the LIQI ADC SPI clock frequency. Set to (PER
//                                                               clock         frequency) / (2 * desired SPI clock
//                                                               frequency). PER clock           frequency is 200MHz and SPI
//                                                               clock frequency should normally be          configured to 10
//                                                               MHz. 16 MHz is the absolute maximum frequency          the
//                                                               LIQI ADC can handle.
//
#define PER_LIQI_CTL1                                                0x0000000000001100ULL
#define PER_LIQI_CTL1_capture_depth                                  0x1000000000001100ULL
#define PER_LIQI_CTL1_spi_halfcycle                                  0x0810000000001100ULL

//
// Register:    PER_LIQI_CTL2
// Description: PER LIQI Control 2 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     sampling_period                20  19:00 RW   0x190       Configures the LIQI ADC sampling period in terms of PER
//                                                               clock cycles. Default value gives 500 kHz sample frequency.
//
#define PER_LIQI_CTL2                                                0x0000000000001104ULL
#define PER_LIQI_CTL2_sampling_period                                0x1400000000001104ULL

//
// Register:    PER_LIQI_STATUS
// Description: PER LIQI Status Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     fifo_depth                     16  15:00 RO   0x0         Reports the current number of ADC samples stored in the data
//                                                               FIFO.
//
#define PER_LIQI_STATUS                                              0x0000000000001108ULL
#define PER_LIQI_STATUS_fifo_depth                                   0x1000000000001108ULL

//
// Register:    PER_LIQI_DATA
// Description: PER LIQI Data Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RO   0x0         Reads from this register attempt to pull one 12-bit sample
//                                                               from the        LIQI data FIFO. Bit 15 is a valid flag
//                                                               indicating whether the FIFO      had an ADC sample to read
//                                                               out. If bit 15 reads 0, the FIFO did not      have an ADC
//                                                               sample to read out, and all other bits in the register
//                                                               will read 0. If bit 15 reads 1, a single 12-bit LIQI ADC
//                                                               sample was     returned in bits 11:0 of the register value.
//                                                               Suggested algorithm for            reading: If the raw
//                                                               32-bit register value is 0, discard the value.      If the
//                                                               raw value is nonzero, mask it with 0x00000FFF to extract the
//                                                               12-bit ADC sample.
//
#define PER_LIQI_DATA                                                0x000000000000110cULL
#define PER_LIQI_DATA_data                                           0x200000000000110cULL

//
// Register:    CHIPIF_HS_CFG1
// Description: High Speed Configuration 1 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     clk_hs_val_high                1       0 RW   0x1         Value to output on the High Speed Interface clock during the
//                                                               high time. Typically one.
//     clk_hs_val_low                 1       1 RW   0x0         Value to output on the High Speed Interface clock during the
//                                                               low time. Typically zero.
//     spi_en                         1       2 RW   0x0         0: Send SMEM updates through HS bus. 1: Send SMEM updates
//                                                               through SPI. NOTE: If this is changed during the middle of a
//                                                               chip row update (1 row is 2048 cells), the change in SMEM
//                                                               update output path is deferred until end of row.
//                                                               CHIPIF_HS_CFG1_spi_status indicates which interface is
//                                                               actually active.
//     spi_status                     1       3 RO   0x0         0: Sending SMEM updates through HS bus. 1: Sending SMEM
//                                                               updates through SPI.
//     smem_noise_mitigation_mode     2   05:04 RW   0x0         0: No noise mitigation. 1: Block SMEM refresh while FPGA
//                                                               thinks chip ADC conversions are in progress. 2: SMEM refresh
//                                                               controlled by userwave's smem_refresh_en bit. 3: Combines
//                                                               modes 1 and 2.
//
#define CHIPIF_HS_CFG1                                               0x0000000000002000ULL
#define CHIPIF_HS_CFG1_clk_hs_val_high                               0x0100000000002000ULL
#define CHIPIF_HS_CFG1_clk_hs_val_low                                0x0101000000002000ULL
#define CHIPIF_HS_CFG1_spi_en                                        0x0102000000002000ULL
#define CHIPIF_HS_CFG1_spi_status                                    0x0103000000002000ULL
#define CHIPIF_HS_CFG1_smem_noise_mitigation_mode                    0x0204000000002000ULL

//
// Register:    CHIPIF_SPI_CFG
// Description: Chip SPI Configuration Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     spi_halfcycle                  8   07:00 RW   0xa         Sets the SPI half-cycle period in units of 200 MHz reference
//                                                               clock cycles. Chip SPI freq in Hz = 200e6 / (spi_halfcycle *
//                                                               2).
//     spi_halfcycle_stretched        8   15:08 RW   0x14        Sets the stretched SPI half-cycle period in units of 200 MHz
//                                                               reference clock cycles. Typically 2x the value of
//                                                               spi_halfcycle.
//     spi_porch_time                 8   23:16 RW   0x0         Sets SPI front/back porch timing. Total time between chip
//                                                               select edge and first/last clock edge is (spi_porch_time /
//                                                               200e6) + (spi_halfcycle / 200e6) seconds.
//     halfcycle_to_stretch           7   30:24 RW   0xf         Selects which half-cycle of the SPI transaction to stretch.
//                                                               Should usually be set to 15 for SeqAll B0/B1 chips (this
//                                                               stretches half-cycle #15, which is the eighth positive pulse
//                                                               of the SPI clock). Disable stretching by setting this field
//                                                               to all-ones.
//     byteswap_en                    1      31 RW   0x1         If 1, automatically byte-swap the 32-bit data payload.
//                                                               Should normally be left on.
//
#define CHIPIF_SPI_CFG                                               0x0000000000002030ULL
#define CHIPIF_SPI_CFG_spi_halfcycle                                 0x0800000000002030ULL
#define CHIPIF_SPI_CFG_spi_halfcycle_stretched                       0x0808000000002030ULL
#define CHIPIF_SPI_CFG_spi_porch_time                                0x0810000000002030ULL
#define CHIPIF_SPI_CFG_halfcycle_to_stretch                          0x0718000000002030ULL
#define CHIPIF_SPI_CFG_byteswap_en                                   0x011f000000002030ULL

//
// Register:    CHIPIF_SPI_CTL
// Description: Chip SPI Control Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     start                          1       0 RW   0x0         The rising edge of this bit starts two 40-bit chip SPI
//                                                               transactions back to back. It is necessary to do two
//                                                               transactions at a time thanks to a chip SPI bug. Each
//                                                               transaction consists of an 8-bit command byte and 32-bit
//                                                               data.   Transaction 1: CHIPIF_SPI_CMDBYTE_txdat1,
//                                                               CHIPIF_SPI_TXDATA1_dat   Transaction 2:
//                                                               CHIPIF_SPI_CMDBYTE_txdat2, CHIPIF_SPI_TXDATA2_dat Received
//                                                               data is stored in:   Transaction 1:
//                                                               CHIPIF_SPI_CMDBYTE_rxdat1, CHIPIF_SPI_RXDATA1_dat
//                                                               Transaction 2: CHIPIF_SPI_CMDBYTE_rxdat2,
//                                                               CHIPIF_SPI_RXDATA2_dat After both commands are complete,
//                                                               CHIPIF_SPI_CTL_complete will be set to 1.
//     complete                       1       1 RW1C 0x0         Reads 1 after a transaction pair has completed. Sticky,
//                                                               write 1 to clear.
//
#define CHIPIF_SPI_CTL                                               0x0000000000002034ULL
#define CHIPIF_SPI_CTL_start                                         0x0100000000002034ULL
#define CHIPIF_SPI_CTL_complete                                      0x0101000000002034ULL

//
// Register:    CHIPIF_SPI_CMDBYTE
// Description: Chip SPI TX Command Bytes
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     txdat1                         8   07:00 RW   0x0         8-bit chip SPI TX command byte (see SeqAll documentation).
//                                                               Fill this out before initiating a SPI transaction.
//     txdat2                         8   15:08 RW   0x0         8-bit chip SPI TX command byte (see SeqAll documentation).
//                                                               Fill this out before initiating a SPI transaction.
//     rxdat1                         8   23:16 RO   0x0         8-bit chip SPI data received while sending
//                                                               CHIPIF_SPI_CMDBYTE_txdat1.
//     rxdat2                         8   31:24 RO   0x0         8-bit chip SPI data received while sending
//                                                               CHIPIF_SPI_CMDBYTE_txdat2.
//
#define CHIPIF_SPI_CMDBYTE                                           0x0000000000002038ULL
#define CHIPIF_SPI_CMDBYTE_txdat1                                    0x0800000000002038ULL
#define CHIPIF_SPI_CMDBYTE_txdat2                                    0x0808000000002038ULL
#define CHIPIF_SPI_CMDBYTE_rxdat1                                    0x0810000000002038ULL
#define CHIPIF_SPI_CMDBYTE_rxdat2                                    0x0818000000002038ULL

//
// Register:    CHIPIF_SPI_TXDATA1
// Description: Chip SPI TX Data Register 1
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     dat                            32  31:00 RW   0x0         Last 32 bits of transmitted data in the first of two 40 bit
//                                                               SPI transactions.
//
#define CHIPIF_SPI_TXDATA1                                           0x000000000000203cULL
#define CHIPIF_SPI_TXDATA1_dat                                       0x200000000000203cULL

//
// Register:    CHIPIF_SPI_TXDATA2
// Description: Chip SPI TX Data Register 2
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     dat                            32  31:00 RW   0x0         Last 32 bits of transmitted data in the second of two 40 bit
//                                                               SPI transactions.
//
#define CHIPIF_SPI_TXDATA2                                           0x0000000000002040ULL
#define CHIPIF_SPI_TXDATA2_dat                                       0x2000000000002040ULL

//
// Register:    CHIPIF_SPI_RXDATA1
// Description: Chip SPI RX data Register 1
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     dat                            32  31:00 RO   0x0         Last 32 bits of received data in the first of two SPI
//                                                               transactions.
//
#define CHIPIF_SPI_RXDATA1                                           0x0000000000002044ULL
#define CHIPIF_SPI_RXDATA1_dat                                       0x2000000000002044ULL

//
// Register:    CHIPIF_SPI_RXDATA2
// Description: Chip SPI RX data Register 2
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     dat                            32  31:00 RO   0x0         Last 32 bits of received data in the second of two SPI
//                                                               transactions.
//
#define CHIPIF_SPI_RXDATA2                                           0x0000000000002048ULL
#define CHIPIF_SPI_RXDATA2_dat                                       0x2000000000002048ULL

//
// Register:    CHIPIF_SPI_UPDATE_CTR
// Description: Counter register which returns the number of SMEM bits written through SPI since the last read.
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     ctr                            32  31:00 RO   0x0         Number of chip SMEM update bits written through SPI. Resets
//                                                               to 0 on read. Saturates at 0xFFFFFFFF if software does not
//                                                               poll often enough.
//
#define CHIPIF_SPI_UPDATE_CTR                                        0x0000000000002060ULL
#define CHIPIF_SPI_UPDATE_CTR_ctr                                    0x2000000000002060ULL

//
// Register:    CHIPIF_HS_UPDATE_CTR
// Description: Counter register which returns the number of SMEM bits written through HS since the last read.
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     ctr                            32  31:00 RO   0x0         Number of chip SMEM update bits written through HS. Resets
//                                                               to 0 on read. Saturates at 0xFFFFFFFF if software does not
//                                                               poll often enough.
//
#define CHIPIF_HS_UPDATE_CTR                                         0x0000000000002064ULL
#define CHIPIF_HS_UPDATE_CTR_ctr                                     0x2000000000002064ULL

//
// Register:    LVDS_BANK_ENABLE0
// Description: The register to select lower 32 lvds lanes
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     bank_enable0                   32  31:00 RW   0xffffffff  Set bits to 1 to enable the corresponding LVDS lane. Bits
//                                                               31:0 map to lanes 31:0
//
#define LVDS_BANK_ENABLE0                                            0x0000000000040000ULL
#define LVDS_BANK_ENABLE0_bank_enable0                               0x2000000000040000ULL

//
// Register:    LVDS_BANK_ENABLE1
// Description: The register to select upper 32 lvds lanes
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     bank_enable1                   32  31:00 RW   0xffffffff  Set bits to 1 to enable the corresponding LVDS lane. Bits
//                                                               31:0 map to lanes 63:32.
//
#define LVDS_BANK_ENABLE1                                            0x0000000000040004ULL
#define LVDS_BANK_ENABLE1_bank_enable1                               0x2000000000040004ULL

//
// Register:    LVDS_HSSIO_CTL
// Description: LVDS HSSIO Control Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     reset_hssio                    1       0 RW   0x0         Reset HSSIO Rx
//
#define LVDS_HSSIO_CTL                                               0x0000000000040008ULL
#define LVDS_HSSIO_CTL_reset_hssio                                   0x0100000000040008ULL

//
// Register:    LVDS_HSSIO_BANKA_STATUS
// Description: Status for HSSIO bank A (Laguna rev1: bank 69, rev2: bank 64)
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     pll_locked                     1       0 RO   0x0         PLL locked
//     rst_seq_done                   1       1 RO   0x0         Indicates that the reset sequence is completed
//     dly_rdy                        8   11:04 RO   0x0         Status bit indicating finish of initial fixed delay line
//                                                               calibration
//     vtc_rdy                        8   19:12 RO   0x0         Status bit indicating finish of baseline VT calibration and
//                                                               tracking
//
#define LVDS_HSSIO_BANKA_STATUS                                      0x000000000004000cULL
#define LVDS_HSSIO_BANKA_STATUS_pll_locked                           0x010000000004000cULL
#define LVDS_HSSIO_BANKA_STATUS_rst_seq_done                         0x010100000004000cULL
#define LVDS_HSSIO_BANKA_STATUS_dly_rdy                              0x080400000004000cULL
#define LVDS_HSSIO_BANKA_STATUS_vtc_rdy                              0x080c00000004000cULL

//
// Register:    LVDS_HSSIO_BANKB_STATUS
// Description: Status for HSSIO bank B (Laguna rev1: bank 70, rev2: bank 66)
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     pll_locked                     1       0 RO   0x0         PLL locked
//     rst_seq_done                   1       1 RO   0x0         Indicates that the reset sequence is completed
//     dly_rdy                        8   11:04 RO   0x0         Status bit indicating finish of initial fixed delay line
//                                                               calibration
//     vtc_rdy                        8   19:12 RO   0x0         Status bit indicating finish of baseline VT calibration and
//                                                               tracking
//
#define LVDS_HSSIO_BANKB_STATUS                                      0x0000000000040010ULL
#define LVDS_HSSIO_BANKB_STATUS_pll_locked                           0x0100000000040010ULL
#define LVDS_HSSIO_BANKB_STATUS_rst_seq_done                         0x0101000000040010ULL
#define LVDS_HSSIO_BANKB_STATUS_dly_rdy                              0x0804000000040010ULL
#define LVDS_HSSIO_BANKB_STATUS_vtc_rdy                              0x080c000000040010ULL

//
// Register:    LVDS_HSSIO_BANKC_STATUS
// Description: Status for HSSIO bank C (Laguna rev1: bank 71, rev2: bank 67)
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     pll_locked                     1       0 RO   0x0         PLL locked
//     rst_seq_done                   1       1 RO   0x0         Indicates that the reset sequence is completed
//     dly_rdy                        8   11:04 RO   0x0         Status bit indicating finish of initial fixed delay line
//                                                               calibration
//     vtc_rdy                        8   19:12 RO   0x0         Status bit indicating finish of baseline VT calibration and
//                                                               tracking
//
#define LVDS_HSSIO_BANKC_STATUS                                      0x0000000000040014ULL
#define LVDS_HSSIO_BANKC_STATUS_pll_locked                           0x0100000000040014ULL
#define LVDS_HSSIO_BANKC_STATUS_rst_seq_done                         0x0101000000040014ULL
#define LVDS_HSSIO_BANKC_STATUS_dly_rdy                              0x0804000000040014ULL
#define LVDS_HSSIO_BANKC_STATUS_vtc_rdy                              0x080c000000040014ULL

//
// Register:    LVDS_PRBS_ENABLE0
// Description: Enables or disables PRBS mode for each LVDS framer. Should be configured to match sensor chip PRBS mode.
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     en                             32  31:00 RW   0x0         Set bits to 1 to enable PRBS in corresponding LVDS lanes.
//                                                               Bits 31:0 map to lanes 31:0. A framer in PRBS mode cannot
//                                                               receive sequencing data normally, and reports PRBS errors as
//                                                               if they are framing errors.
//
#define LVDS_PRBS_ENABLE0                                            0x0000000000040020ULL
#define LVDS_PRBS_ENABLE0_en                                         0x2000000000040020ULL

//
// Register:    LVDS_PRBS_ENABLE1
// Description: Enables or disables PRBS mode for each LVDS framer. Should be configured to match sensor chip PRBS mode.
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     en                             32  31:00 RW   0x0         Set bits to 1 to enable PRBS in corresponding LVDS lanes.
//                                                               Bits 31:0 map to lanes 63:32. A framer in PRBS mode cannot
//                                                               receive sequencing data normally, and reports PRBS errors as
//                                                               if they are framing errors.
//
#define LVDS_PRBS_ENABLE1                                            0x0000000000040024ULL
#define LVDS_PRBS_ENABLE1_en                                         0x2000000000040024ULL

//
// Register:    LVDS_FRAME_ERR0
// Description: LVDS Frame Error 0 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     err0                           32  31:00 RW1C 0x0         Latched framing error status for lanes 31:0. Write 1 to
//                                                               clear.
//
#define LVDS_FRAME_ERR0                                              0x0000000000040028ULL
#define LVDS_FRAME_ERR0_err0                                         0x2000000000040028ULL

//
// Register:    LVDS_FRAME_ERR1
// Description: LVDS Frame Error 1 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     err1                           32  31:00 RW1C 0x0         Latched framing error status for lanes 63:32. Write 1 to
//                                                               clear.
//
#define LVDS_FRAME_ERR1                                              0x000000000004002cULL
#define LVDS_FRAME_ERR1_err1                                         0x200000000004002cULL

//
// Register:    LVDS_CONTROL0
// Description: LVDS control 0 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     skip_row                       1       0 RW   0x0         Skip all odd # rows. When one, frame_row_start/frame_row_end
//                                                               must be even.
//     header_crc_enable              1       2 RW   0x1         When one, the FPGA will check that CRC in the last 32 bits
//                                                               of the frame match the calculated value.
//     data_invert                    1       3 RW   0x0         Invert the data (new_data = 255-LVDS_data). Header/footer
//                                                               are not inverted.
//     reorder_dis                    1       4 RW   0x0         Disable reordering of bytes. Bytes will be saved in time
//                                                               order instead of cell number order. No other part of the
//                                                               FPGA looks at this setting, it is for debug only.
//     insert_lane_id                 1       5 RW   0x0         Replaces byte 12 of the header in each LVDS lane with the
//                                                               LVDS lane ID.
//     test_pattern_en                1       6 RW   0x0         Replace LVDS data with a test pattern. Header and footer are
//                                                               not modified. 0=disabled (normal data). 1={10’d0, lane[5:0],
//                                                               frame_ctr[15:0], 7’d0, row[8:0], byte_ctr[15:0]}.
//     framing_error_threshold        5   11:07 RW   0x0         LVDS framer’s error tolerance threshold. Controls the 16-bit
//                                                               comparators which each LVDS lane’s framer uses to detect the
//                                                               16-bit idle pattern and (over two comparisons) the 32-bit
//                                                               header sync pattern. Set to 0 to require a perfect match, 1
//                                                               to declare a match with at most 1 bit wrong per 16 bits of
//                                                               framing data, 2 to match with at most 2 errors per 16, and
//                                                               so forth.
//     reorder_flush                  1      12 RW   0x0         Set to 1 to flush the LVDS reordering data pipeline. This
//                                                               should not be used during a capture, and must be programmed
//                                                               back to 0 for data to flow through the reorder module.
//
#define LVDS_CONTROL0                                                0x0000000000040030ULL
#define LVDS_CONTROL0_skip_row                                       0x0100000000040030ULL
#define LVDS_CONTROL0_header_crc_enable                              0x0102000000040030ULL
#define LVDS_CONTROL0_data_invert                                    0x0103000000040030ULL
#define LVDS_CONTROL0_reorder_dis                                    0x0104000000040030ULL
#define LVDS_CONTROL0_insert_lane_id                                 0x0105000000040030ULL
#define LVDS_CONTROL0_test_pattern_en                                0x0106000000040030ULL
#define LVDS_CONTROL0_framing_error_threshold                        0x0507000000040030ULL
#define LVDS_CONTROL0_reorder_flush                                  0x010c000000040030ULL

//
// Register:    LVDS_FRAME_WINDOW
// Description: LVDS Frame Window Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     frame_row_end                  9   08:00 RW   0xff        Frame row end
//     frame_row_start                9   24:16 RW   0x0         Frame row start
//
#define LVDS_FRAME_WINDOW                                            0x0000000000040034ULL
#define LVDS_FRAME_WINDOW_frame_row_end                              0x0900000000040034ULL
#define LVDS_FRAME_WINDOW_frame_row_start                            0x0910000000040034ULL

//
// Register:    LVDS_IDLE_SYNC_PATTERN
// Description: LVDS Idle Sync Pattern
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     pattern                        16  15:00 RW   0xf055      Pattern. Must match Sensor chip lvdsif_pattern.
//
#define LVDS_IDLE_SYNC_PATTERN                                       0x0000000000040038ULL
#define LVDS_IDLE_SYNC_PATTERN_pattern                               0x1000000000040038ULL

//
// Register:    LVDS_HEADER_SYNC_PATTERN
// Description: LVDS Header Sync Pattern Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     pattern                        32  31:00 RW   0xfaa0faa   Pattern. Must match Sensor chip srdwr_header_pattern.
//
#define LVDS_HEADER_SYNC_PATTERN                                     0x000000000004003cULL
#define LVDS_HEADER_SYNC_PATTERN_pattern                             0x200000000004003cULL

//
// Register:    LVDS_FRAMER_BER_CTR_CFG
// Description: LVDS DMA Address Log Data Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     lane                           6   05:00 RW   0x0         Selects which LVDS lane’s counters are readable through
//                                                               LVDS_FRAMER_BER_CTR_FBIT* data registers.
//     sample_ctrs                    1       6 RW   0x0         The rising edge of this bit (0 to 1) latches the accumulated
//                                                               counters in all 64 framers, resets the counters, and makes
//                                                               the old accumulated values visible through the data
//                                                               registers.
//
#define LVDS_FRAMER_BER_CTR_CFG                                      0x0000000000040040ULL
#define LVDS_FRAMER_BER_CTR_CFG_lane                                 0x0600000000040040ULL
#define LVDS_FRAMER_BER_CTR_CFG_sample_ctrs                          0x0106000000040040ULL

//
// Register:    LVDS_FRAMER_BER_CTR_FBITS_RCVD
// Description: LVDS Framer BER Counter Framing Bits Received Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     count                          32  31:00 RO   0x0         Count of the number of framing bits received over the last
//                                                               sampling window in LVDS lane LVDS_FRAMER_BER_CTR_CFG_lane. A
//                                                               sampling window is the time between the two most recent
//                                                               transitions of LVDS_FRAMER_BER_CTR_CFG_sample from 0 to 1.
//
#define LVDS_FRAMER_BER_CTR_FBITS_RCVD                               0x0000000000040044ULL
#define LVDS_FRAMER_BER_CTR_FBITS_RCVD_count                         0x2000000000040044ULL

//
// Register:    LVDS_FRAMER_BER_CTR_FBIT_ERRS
// Description: LVDS Framer BER Counter Framing Bit Errors Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     count                          32  31:00 RO   0x0         Count of the number of framing bit errors over the last
//                                                               sampling window in LVDS lane LVDS_FRAMER_BER_CTR_CFG_lane. A
//                                                               sampling window is the time between the two most recent
//                                                               transitions of LVDS_FRAMER_BER_CTR_CFG_sample from 0 to 1
//
#define LVDS_FRAMER_BER_CTR_FBIT_ERRS                                0x0000000000040048ULL
#define LVDS_FRAMER_BER_CTR_FBIT_ERRS_count                          0x2000000000040048ULL

//
// Register:    LVDS_CHIP_CTL1
// Description: Sensor Chip Control
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     reset                          1       0 RW   0x1         Reset sensor chip
//
#define LVDS_CHIP_CTL1                                               0x0000000000040050ULL
#define LVDS_CHIP_CTL1_reset                                         0x0100000000040050ULL

//
// Register:    LVDS_DMA_CTL
// Description: LVDS DMA control Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     max_frame_group                16  15:00 RW   0x0         Maximum number of frame groups to capture. Write to zero to
//                                                               reset the internal counter. A value of zero disables all
//                                                               DMA, the maximum values indicates infinite.
//     dma_flush                      1      31 RW   0x1         Flush out prefetched DMA addresses. Must be cleared AFTER
//                                                               setting up the frame data DMA descriptor.
//
#define LVDS_DMA_CTL                                                 0x0000000000040054ULL
#define LVDS_DMA_CTL_max_frame_group                                 0x1000000000040054ULL
#define LVDS_DMA_CTL_dma_flush                                       0x011f000000040054ULL

//
// Register:    LVDS_TIMESTAMP_L
// Description: LVDS Timestamp Low Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RO   0x0         Timestamp low. Reading this register also takes a snapshot
//                                                               of the timestamp high value. Reported in number of LVDS
//                                                               clocks divided by four since the LVDS block was reset.
//
#define LVDS_TIMESTAMP_L                                             0x0000000000040058ULL
#define LVDS_TIMESTAMP_L_data                                        0x2000000000040058ULL

//
// Register:    LVDS_TIMESTAMP_H
// Description: LVDS Timestamp High Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RO   0x0         Timestamp high. Read after reading timestamp low.
//
#define LVDS_TIMESTAMP_H                                             0x000000000004005cULL
#define LVDS_TIMESTAMP_H_data                                        0x200000000004005cULL

//
// Register:    LVDS_RECORD_MAP_CTL1
// Description: LVDS Recording Map control 1 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     rbm_fetch_en                   1      25 RW   0x0         0: Compactor RBM fetch is disabled and RBM prefetch FIFOs
//                                                               are flushed. In this state, compactor is unable to process
//                                                               LVDS frame data. 1: Compactor RBM fetch enabled. NOTE: This
//                                                               bit must be set to 0 during RBM changes. During a capture,
//                                                               it must be set to 1.
//
#define LVDS_RECORD_MAP_CTL1                                         0x0000000000040060ULL
#define LVDS_RECORD_MAP_CTL1_rbm_fetch_en                            0x0119000000040060ULL

//
// Register:    LVDS_DEBUG_STATUS1
// Description: LVDS Debug Status1 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     idle_match0                    32  31:00 RW1C 0x0         Idle Match in lanes 31:0. Write 1 to clear.
//
#define LVDS_DEBUG_STATUS1                                           0x0000000000040064ULL
#define LVDS_DEBUG_STATUS1_idle_match0                               0x2000000000040064ULL

//
// Register:    LVDS_DEBUG_STATUS2
// Description: LVDS Debug Status2 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     idle_match1                    32  31:00 RW1C 0x0         Idle Match in lanes 63:32. Write 1 to clear.
//
#define LVDS_DEBUG_STATUS2                                           0x0000000000040068ULL
#define LVDS_DEBUG_STATUS2_idle_match1                               0x2000000000040068ULL

//
// Register:    LVDS_DATA_CTL
// Description: Configures LVDS data transformations.
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     bitslip                        3   02:00 RW   0x0         Configures bitslip (used to byte-align serial data). Apply
//                                                               to one or more lanes by writing a mask to
//                                                               LVDS_DATA_CTL_WRITEMASK_L or LVDS_DATA_CTL_WRITEMASK_H.
//     invert                         1       3 RW   0x0         1 = invert data, 0 = do not invert. Apply to one or more
//                                                               lanes by writing a mask to LVDS_DATA_CTL_WRITEMASK_L or
//                                                               LVDS_DATA_CTL_WRITEMASK_H.
//     dbgsel                         6   10:05 RW   0x0         Sets the LVDS lane used for Chipscope debugging.
//
#define LVDS_DATA_CTL                                                0x0000000000040070ULL
#define LVDS_DATA_CTL_bitslip                                        0x0300000000040070ULL
#define LVDS_DATA_CTL_invert                                         0x0103000000040070ULL
#define LVDS_DATA_CTL_dbgsel                                         0x0605000000040070ULL

//
// Register:    LVDS_DATA_CTL_WRITEMASK_L
// Description: LVDS Raw Data Control Write Mask Low Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     wmask                          32  31:00 RW   0x0         When written to, the values in LVDS_DATA_CTL are applied to
//                                                               one or more LVDS lanes. Write a 1 in the bit position for
//                                                               each lane you want to configure. The Low register configures
//                                                               LVDS lanes 0 to 31 (bit 0 = lane 0, bit 31 = lane 31).
//
#define LVDS_DATA_CTL_WRITEMASK_L                                    0x0000000000040074ULL
#define LVDS_DATA_CTL_WRITEMASK_L_wmask                              0x2000000000040074ULL

//
// Register:    LVDS_DATA_CTL_WRITEMASK_H
// Description: LVDS Raw Data Control Write Mask High Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     wmask                          32  31:00 RW   0x0         When written to, the values in LVDS_DATA_CTL are applied to
//                                                               one or more LVDS lanes. Write a 1 in the bit position for
//                                                               each lane you want to configure. The High register
//                                                               configures LVDS lanes 32 to 63 (bit 0 = lane 32, bit 31 =
//                                                               lane 63).
//
#define LVDS_DATA_CTL_WRITEMASK_H                                    0x0000000000040078ULL
#define LVDS_DATA_CTL_WRITEMASK_H_wmask                              0x2000000000040078ULL

//
// Register:    LVDS_DMA_DESC_CTL
// Description: LVDS DMA descriptor control Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     chan                           8   07:00 RW   0x0         DMA channel.
//     valid                          1       8 RW   0x0         The DMA channel has a valid descriptor. Some DMA agents
//                                                               inside the FPGA will skip the requested DMA when valid=0.
//     dma_error                      1      29 RW1C 0x0         Reads 1 if a DMA error has occurred since the bit was last
//                                                               cleared. Write 1 to clear.
//     write_in_progress              1      30 RO   0x0         Reads 1 while a configuration write is in progress, 0 when
//                                                               it is safe to initiate a descriptor write.
//     dma_write                      1      31 RW   0x0         Write the descriptor when this bit is changed from zero to
//                                                               one. Software must clear this bit before doing another
//                                                               descriptor write.
//
#define LVDS_DMA_DESC_CTL                                            0x0000000000040080ULL
#define LVDS_DMA_DESC_CTL_chan                                       0x0800000000040080ULL
#define LVDS_DMA_DESC_CTL_valid                                      0x0108000000040080ULL
#define LVDS_DMA_DESC_CTL_dma_error                                  0x011d000000040080ULL
#define LVDS_DMA_DESC_CTL_write_in_progress                          0x011e000000040080ULL
#define LVDS_DMA_DESC_CTL_dma_write                                  0x011f000000040080ULL

//
// Register:    LVDS_DMA_DESC_WR_ADDR_L
// Description: LVDS DMA descriptor write address low Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RW   0x0         DMA base address 31:0
//
#define LVDS_DMA_DESC_WR_ADDR_L                                      0x0000000000040084ULL
#define LVDS_DMA_DESC_WR_ADDR_L_data                                 0x2000000000040084ULL

//
// Register:    LVDS_DMA_DESC_WR_ADDR_H
// Description: LVDS DMA descriptor write address high Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RW   0x0         DMA base address 63:32
//
#define LVDS_DMA_DESC_WR_ADDR_H                                      0x0000000000040088ULL
#define LVDS_DMA_DESC_WR_ADDR_H_data                                 0x2000000000040088ULL

//
// Register:    LVDS_DMA_DESC_WR_SIZE_L
// Description: LVDS DMA descriptor write size low Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RW   0x0         DMA buffer size (in bytes) 31:0
//
#define LVDS_DMA_DESC_WR_SIZE_L                                      0x000000000004008cULL
#define LVDS_DMA_DESC_WR_SIZE_L_data                                 0x200000000004008cULL

//
// Register:    LVDS_DMA_DESC_WR_SIZE_H
// Description: LVDS DMA descriptor write size high Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RW   0x0         DMA buffer size (in bytes) 63:32
//
#define LVDS_DMA_DESC_WR_SIZE_H                                      0x0000000000040090ULL
#define LVDS_DMA_DESC_WR_SIZE_H_data                                 0x2000000000040090ULL

//
// Register:    LVDS_DMA_DESC_RD_ADDR_L
// Description: LVDS DMA descriptor read address low Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RO   0x0         DMA base address 31:0
//
#define LVDS_DMA_DESC_RD_ADDR_L                                      0x0000000000040094ULL
#define LVDS_DMA_DESC_RD_ADDR_L_data                                 0x2000000000040094ULL

//
// Register:    LVDS_DMA_DESC_RD_ADDR_H
// Description: LVDS DMA descriptor read address high Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RO   0x0         DMA base address 63:32
//
#define LVDS_DMA_DESC_RD_ADDR_H                                      0x0000000000040098ULL
#define LVDS_DMA_DESC_RD_ADDR_H_data                                 0x2000000000040098ULL

//
// Register:    LVDS_DMA_DESC_RD_SIZE_L
// Description: LVDS DMA descriptor read size low Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RO   0x0         DMA buffer size (in bytes) 31:0
//
#define LVDS_DMA_DESC_RD_SIZE_L                                      0x000000000004009cULL
#define LVDS_DMA_DESC_RD_SIZE_L_data                                 0x200000000004009cULL

//
// Register:    LVDS_DMA_DESC_RD_SIZE_H
// Description: LVDS DMA descriptor read size high Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RO   0x0         DMA buffer size (in bytes) 63:32
//
#define LVDS_DMA_DESC_RD_SIZE_H                                      0x00000000000400a0ULL
#define LVDS_DMA_DESC_RD_SIZE_H_data                                 0x20000000000400a0ULL

//
// Register:    LVDS_DMA_DESC_RD_OFFSET_L
// Description: LVDS DMA descriptor read offset low Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RO   0x0         DMA current offset into the buffer 31:0
//
#define LVDS_DMA_DESC_RD_OFFSET_L                                    0x00000000000400a4ULL
#define LVDS_DMA_DESC_RD_OFFSET_L_data                               0x20000000000400a4ULL

//
// Register:    LVDS_DMA_DESC_RD_OFFSET_H
// Description: LVDS DMA descriptor read offset high Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RO   0x0         DMA current offset into the buffer 63:32
//
#define LVDS_DMA_DESC_RD_OFFSET_H                                    0x00000000000400a8ULL
#define LVDS_DMA_DESC_RD_OFFSET_H_data                               0x20000000000400a8ULL

//
// Register:    LVDS_HSSIO_BANKA_RIU_CFG
// Description: LVDS HSSIO Bank A RIU Cfg Regsiter (Laguna rev1: bank 69, rev2: bank 64)
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     wr_data                        16  15:00 RW   0x0         Write data
//     wr_en                          1      16 RW   0x0         Write enable
//     addr                           9   25:17 RW   0x0         addr
//
#define LVDS_HSSIO_BANKA_RIU_CFG                                     0x00000000000400b0ULL
#define LVDS_HSSIO_BANKA_RIU_CFG_wr_data                             0x10000000000400b0ULL
#define LVDS_HSSIO_BANKA_RIU_CFG_wr_en                               0x01100000000400b0ULL
#define LVDS_HSSIO_BANKA_RIU_CFG_addr                                0x09110000000400b0ULL

//
// Register:    LVDS_HSSIO_BANKA_RIU_STATUS
// Description: LVDS HSSIO Bank A RIU Status Regsiter (Laguna rev1: bank 69, rev2: bank 64)
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     rd_data                        16  15:00 RO   0x0         Read data
//     rd_vld                         1      16 RO   0x0         Read valid
//
#define LVDS_HSSIO_BANKA_RIU_STATUS                                  0x00000000000400b4ULL
#define LVDS_HSSIO_BANKA_RIU_STATUS_rd_data                          0x10000000000400b4ULL
#define LVDS_HSSIO_BANKA_RIU_STATUS_rd_vld                           0x01100000000400b4ULL

//
// Register:    LVDS_HSSIO_BANKB_RIU_CFG
// Description: LVDS HSSIO Bank B RIU Cfg Regsiter (Laguna rev1: bank 70, rev2: bank 66)
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     wr_data                        16  15:00 RW   0x0         Write data
//     wr_en                          1      16 RW   0x0         Write enable
//     addr                           9   25:17 RW   0x0         addr
//
#define LVDS_HSSIO_BANKB_RIU_CFG                                     0x00000000000400b8ULL
#define LVDS_HSSIO_BANKB_RIU_CFG_wr_data                             0x10000000000400b8ULL
#define LVDS_HSSIO_BANKB_RIU_CFG_wr_en                               0x01100000000400b8ULL
#define LVDS_HSSIO_BANKB_RIU_CFG_addr                                0x09110000000400b8ULL

//
// Register:    LVDS_HSSIO_BANKB_RIU_STATUS
// Description: LVDS HSSIO Bank B RIU Status Regsiter (Laguna rev1: bank 70, rev2: bank 66)
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     rd_data                        16  15:00 RO   0x0         Read data
//     rd_vld                         1      16 RO   0x0         Read valid
//
#define LVDS_HSSIO_BANKB_RIU_STATUS                                  0x00000000000400bcULL
#define LVDS_HSSIO_BANKB_RIU_STATUS_rd_data                          0x10000000000400bcULL
#define LVDS_HSSIO_BANKB_RIU_STATUS_rd_vld                           0x01100000000400bcULL

//
// Register:    LVDS_HSSIO_BANKC_RIU_CFG
// Description: LVDS HSSIO Bank C RIU Cfg Regsiter (Laguna rev1: bank 71, rev2: bank 67)
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     wr_data                        16  15:00 RW   0x0         Write data
//     wr_en                          1      16 RW   0x0         Write enable
//     addr                           9   25:17 RW   0x0         addr
//
#define LVDS_HSSIO_BANKC_RIU_CFG                                     0x00000000000400c0ULL
#define LVDS_HSSIO_BANKC_RIU_CFG_wr_data                             0x10000000000400c0ULL
#define LVDS_HSSIO_BANKC_RIU_CFG_wr_en                               0x01100000000400c0ULL
#define LVDS_HSSIO_BANKC_RIU_CFG_addr                                0x09110000000400c0ULL

//
// Register:    LVDS_HSSIO_BANKC_RIU_STATUS
// Description: LVDS HSSIO Bank C RIU Status Regsiter (Laguna rev1: bank 71, rev2: bank 67)
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     rd_data                        16  15:00 RO   0x0         Read data
//     rd_vld                         1      16 RO   0x0         Read valid
//
#define LVDS_HSSIO_BANKC_RIU_STATUS                                  0x00000000000400c4ULL
#define LVDS_HSSIO_BANKC_RIU_STATUS_rd_data                          0x10000000000400c4ULL
#define LVDS_HSSIO_BANKC_RIU_STATUS_rd_vld                           0x01100000000400c4ULL

//
// Register:    LVDS_SPI_CTL1
// Description: SPI control and configuration 1 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     convtime                       16  15:00 RW   0x200       Conversion time (in clock cycles of the internal LVDS byte
//                                                               clock). Minimum value according to datasheet: 3.7us
//     acqtime                        16  31:16 RW   0x140       Acquisition time (in clock cycles of the internal LVDS byte
//                                                               clock). Minimum value according to datasheet: 2.01us
//
#define LVDS_SPI_CTL1                                                0x00000000000400e0ULL
#define LVDS_SPI_CTL1_convtime                                       0x10000000000400e0ULL
#define LVDS_SPI_CTL1_acqtime                                        0x10100000000400e0ULL

//
// Register:    LVDS_SPI_CTL2
// Description: SPI control and configuration 2 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     spi_adc0_halfcycle             8   07:00 RW   0x20        1/2 of the SPI clock period for the ADC0 SPI interface (in
//                                                               clock cycles of the internal LVDS byte clock). Exceeding
//                                                               2MHz may cause the SPI interface to stop working properly
//     spi_adc1_halfcycle             8   15:08 RW   0x20        ADC1 halfcycle
//     spi_adc2_halfcycle             8   23:16 RW   0x20        ADC2 halfcycle
//     spi_dac0_halfcycle             8   31:24 RW   0x2         DAC0 halfcycle
//
#define LVDS_SPI_CTL2                                                0x00000000000400e4ULL
#define LVDS_SPI_CTL2_spi_adc0_halfcycle                             0x08000000000400e4ULL
#define LVDS_SPI_CTL2_spi_adc1_halfcycle                             0x08080000000400e4ULL
#define LVDS_SPI_CTL2_spi_adc2_halfcycle                             0x08100000000400e4ULL
#define LVDS_SPI_CTL2_spi_dac0_halfcycle                             0x08180000000400e4ULL

//
// Register:    LVDS_ADC01_00
// Description: Board ADC Values
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data0                          16  15:00 RO   0x0         ADC value. See spec.
//     data1                          16  31:16 RO   0x0         ADC value. See spec.
//
#define LVDS_ADC01_00                                                0x0000000000040100ULL
#define LVDS_ADC01_00_data0                                          0x1000000000040100ULL
#define LVDS_ADC01_00_data1                                          0x1010000000040100ULL

//
// Register:    LVDS_ADC03_02
// Description: Board ADC Values
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data0                          16  15:00 RO   0x0         ADC value. See spec.
//     data1                          16  31:16 RO   0x0         ADC value. See spec.
//
#define LVDS_ADC03_02                                                0x0000000000040104ULL
#define LVDS_ADC03_02_data0                                          0x1000000000040104ULL
#define LVDS_ADC03_02_data1                                          0x1010000000040104ULL

//
// Register:    LVDS_ADC05_04
// Description: Board ADC Values Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data0                          16  15:00 RO   0x0         ADC value. See spec.
//     data1                          16  31:16 RO   0x0         ADC value. See spec.
//
#define LVDS_ADC05_04                                                0x0000000000040108ULL
#define LVDS_ADC05_04_data0                                          0x1000000000040108ULL
#define LVDS_ADC05_04_data1                                          0x1010000000040108ULL

//
// Register:    LVDS_ADC07_06
// Description: Board ADC Values
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data0                          16  15:00 RO   0x0         ADC value. See spec.
//     data1                          16  31:16 RO   0x0         ADC value. See spec.
//
#define LVDS_ADC07_06                                                0x000000000004010cULL
#define LVDS_ADC07_06_data0                                          0x100000000004010cULL
#define LVDS_ADC07_06_data1                                          0x101000000004010cULL

//
// Register:    LVDS_ADC09_08
// Description: Board ADC Values
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data0                          16  15:00 RO   0x0         ADC value. See spec.
//     data1                          16  31:16 RO   0x0         ADC value. See spec.
//
#define LVDS_ADC09_08                                                0x0000000000040110ULL
#define LVDS_ADC09_08_data0                                          0x1000000000040110ULL
#define LVDS_ADC09_08_data1                                          0x1010000000040110ULL

//
// Register:    LVDS_ADC11_10
// Description: Board ADC Values Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data0                          16  15:00 RO   0x0         ADC value. See spec.
//     data1                          16  31:16 RO   0x0         ADC value. See spec.
//
#define LVDS_ADC11_10                                                0x0000000000040114ULL
#define LVDS_ADC11_10_data0                                          0x1000000000040114ULL
#define LVDS_ADC11_10_data1                                          0x1010000000040114ULL

//
// Register:    LVDS_ADC13_12
// Description: Board ADC Values Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data0                          16  15:00 RO   0x0         ADC value. See spec.
//     data1                          16  31:16 RO   0x0         ADC value. See spec.
//
#define LVDS_ADC13_12                                                0x0000000000040118ULL
#define LVDS_ADC13_12_data0                                          0x1000000000040118ULL
#define LVDS_ADC13_12_data1                                          0x1010000000040118ULL

//
// Register:    LVDS_ADC15_14
// Description: Board ADC Values Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data0                          16  15:00 RO   0x0         ADC value. See spec.
//     data1                          16  31:16 RO   0x0         ADC value. See spec.
//
#define LVDS_ADC15_14                                                0x000000000004011cULL
#define LVDS_ADC15_14_data0                                          0x100000000004011cULL
#define LVDS_ADC15_14_data1                                          0x101000000004011cULL

//
// Register:    LVDS_ADC17_16
// Description: Board ADC Values Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data0                          16  15:00 RO   0x0         ADC value. See spec.
//     data1                          16  31:16 RO   0x0         ADC value. See spec.
//
#define LVDS_ADC17_16                                                0x0000000000040120ULL
#define LVDS_ADC17_16_data0                                          0x1000000000040120ULL
#define LVDS_ADC17_16_data1                                          0x1010000000040120ULL

//
// Register:    LVDS_ADC19_18
// Description: Board ADC Values Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data0                          16  15:00 RO   0x0         ADC value. See spec.
//     data1                          16  31:16 RO   0x0         ADC value. See spec.
//
#define LVDS_ADC19_18                                                0x0000000000040124ULL
#define LVDS_ADC19_18_data0                                          0x1000000000040124ULL
#define LVDS_ADC19_18_data1                                          0x1010000000040124ULL

//
// Register:    LVDS_ADC21_20
// Description: Board ADC Values Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data0                          16  15:00 RO   0x0         ADC value. See spec.
//     data1                          16  31:16 RO   0x0         ADC value. See spec.
//
#define LVDS_ADC21_20                                                0x0000000000040128ULL
#define LVDS_ADC21_20_data0                                          0x1000000000040128ULL
#define LVDS_ADC21_20_data1                                          0x1010000000040128ULL

//
// Register:    LVDS_ADC23_22
// Description: Board ADC Values Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data0                          16  15:00 RO   0x0         ADC value. See spec.
//     data1                          16  31:16 RO   0x0         ADC value. See spec.
//
#define LVDS_ADC23_22                                                0x000000000004012cULL
#define LVDS_ADC23_22_data0                                          0x100000000004012cULL
#define LVDS_ADC23_22_data1                                          0x101000000004012cULL

//
// Register:    LVDS_ADC25_24
// Description: Board ADC Values Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data0                          16  15:00 RO   0x0         ADC value. See spec.
//     data1                          16  31:16 RO   0x0         ADC value. See spec.
//
#define LVDS_ADC25_24                                                0x0000000000040130ULL
#define LVDS_ADC25_24_data0                                          0x1000000000040130ULL
#define LVDS_ADC25_24_data1                                          0x1010000000040130ULL

//
// Register:    LVDS_ADC27_26
// Description: Board ADC Values
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data0                          16  15:00 RO   0x0         ADC value. See spec.
//     data1                          16  31:16 RO   0x0         ADC value. See spec.
//
#define LVDS_ADC27_26                                                0x0000000000040134ULL
#define LVDS_ADC27_26_data0                                          0x1000000000040134ULL
#define LVDS_ADC27_26_data1                                          0x1010000000040134ULL

//
// Register:    LVDS_ADC29_28
// Description: Board ADC Values Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data0                          16  15:00 RO   0x0         ADC value. See spec.
//     data1                          16  31:16 RO   0x0         ADC value. See spec.
//
#define LVDS_ADC29_28                                                0x0000000000040138ULL
#define LVDS_ADC29_28_data0                                          0x1000000000040138ULL
#define LVDS_ADC29_28_data1                                          0x1010000000040138ULL

//
// Register:    LVDS_ADC31_30
// Description: Board ADC Values Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data0                          16  15:00 RO   0x0         ADC value. See spec.
//     data1                          16  31:16 RO   0x0         ADC value. See spec.
//
#define LVDS_ADC31_30                                                0x000000000004013cULL
#define LVDS_ADC31_30_data0                                          0x100000000004013cULL
#define LVDS_ADC31_30_data1                                          0x101000000004013cULL

//
// Register:    LVDS_ADC33_32
// Description: Board ADC Values Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data0                          16  15:00 RO   0x0         ADC value. See spec.
//     data1                          16  31:16 RO   0x0         ADC value. See spec.
//
#define LVDS_ADC33_32                                                0x0000000000040140ULL
#define LVDS_ADC33_32_data0                                          0x1000000000040140ULL
#define LVDS_ADC33_32_data1                                          0x1010000000040140ULL

//
// Register:    LVDS_ADC35_34
// Description: Board ADC Values Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data0                          16  15:00 RO   0x0         ADC value. See spec.
//     data1                          16  31:16 RO   0x0         ADC value. See spec.
//
#define LVDS_ADC35_34                                                0x0000000000040144ULL
#define LVDS_ADC35_34_data0                                          0x1000000000040144ULL
#define LVDS_ADC35_34_data1                                          0x1010000000040144ULL

//
// Register:    LVDS_ADC37_36
// Description: Board ADC Values Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data0                          16  15:00 RO   0x0         ADC value. See spec.
//     data1                          16  31:16 RO   0x0         ADC value. See spec.
//
#define LVDS_ADC37_36                                                0x0000000000040148ULL
#define LVDS_ADC37_36_data0                                          0x1000000000040148ULL
#define LVDS_ADC37_36_data1                                          0x1010000000040148ULL

//
// Register:    LVDS_ADC39_38
// Description: Board ADC Values
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data0                          16  15:00 RO   0x0         ADC value. See spec.
//     data1                          16  31:16 RO   0x0         ADC value. See spec.
//
#define LVDS_ADC39_38                                                0x000000000004014cULL
#define LVDS_ADC39_38_data0                                          0x100000000004014cULL
#define LVDS_ADC39_38_data1                                          0x101000000004014cULL

//
// Register:    LVDS_ADC41_40
// Description: Board ADC Values
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data0                          16  15:00 RO   0x0         ADC value. See spec.
//     data1                          16  31:16 RO   0x0         ADC value. See spec.
//
#define LVDS_ADC41_40                                                0x0000000000040150ULL
#define LVDS_ADC41_40_data0                                          0x1000000000040150ULL
#define LVDS_ADC41_40_data1                                          0x1010000000040150ULL

//
// Register:    LVDS_ADC43_42
// Description: Board ADC Values Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data0                          16  15:00 RO   0x0         ADC value. See spec.
//     data1                          16  31:16 RO   0x0         ADC value. See spec.
//
#define LVDS_ADC43_42                                                0x0000000000040154ULL
#define LVDS_ADC43_42_data0                                          0x1000000000040154ULL
#define LVDS_ADC43_42_data1                                          0x1010000000040154ULL

//
// Register:    LVDS_ADC45_44
// Description: Board ADC Values
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data0                          16  15:00 RO   0x0         ADC value. See spec.
//     data1                          16  31:16 RO   0x0         ADC value. See spec.
//
#define LVDS_ADC45_44                                                0x0000000000040158ULL
#define LVDS_ADC45_44_data0                                          0x1000000000040158ULL
#define LVDS_ADC45_44_data1                                          0x1010000000040158ULL

//
// Register:    LVDS_ADC47_46
// Description: Board ADC Values Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data0                          16  15:00 RO   0x0         ADC value. See spec.
//     data1                          16  31:16 RO   0x0         ADC value. See spec.
//
#define LVDS_ADC47_46                                                0x000000000004015cULL
#define LVDS_ADC47_46_data0                                          0x100000000004015cULL
#define LVDS_ADC47_46_data1                                          0x101000000004015cULL

//
// Register:    LVDS_ADC49_48
// Description: Board ADC Values Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data0                          16  15:00 RO   0x0         ADC value. See spec.
//     data1                          16  31:16 RO   0x0         ADC value. See spec.
//
#define LVDS_ADC49_48                                                0x0000000000040160ULL
#define LVDS_ADC49_48_data0                                          0x1000000000040160ULL
#define LVDS_ADC49_48_data1                                          0x1010000000040160ULL

//
// Register:    LVDS_USERWAVE_CTL
// Description: Userwave control
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     enable_fetch                   1       0 RW   0x0         Enables userwave DMA fetch. Fetcher will read commands from
//                                                               FPGA DRAM and buffer them in a FIFO that feeds the execution
//                                                               engine.
//     flush                          1       1 RW   0x0         Set to 1 to flush all commands from the fetcher. Does not
//                                                               flush commands that have moved out of fetch into execute.
//     halt_request                   1       2 RW   0x0         Set to 1 to request userwave fetch to stop after issuing the
//                                                               next command marked as a safe halting point
//                                                               (“read_safe_halting_point” bit in the command word is set to
//                                                               1).
//     setvoltages_req                1       3 RW   0x0         The rising edge of this bit (program to 0, then to 1) queues
//                                                               a request to set userwave controlled DAC channels and
//                                                               voltage switches to the values found in
//                                                               LVDS_DAC_U58/61/SWITCHES_* register fields. This request
//                                                               will be processed when the userwave execution engine is idle
//                                                               because it has run out of ordinary commands to run. Status
//                                                               is reported in LVDS_USERWAVE_STATUS1_setvoltages_req_queued.
//                                                               NOTE: The request will trigger on any underrun, whether
//                                                               intentional or not, so for robustness, software should defer
//                                                               queueing a request until it knows  it is done feeding
//                                                               commands to the userwave ring buffer.
//     precharge_while_idle           1       4 RW   0x0         If 1, while the userwave engine is idle (no normal or
//                                                               generated commands to execute), the userwave engine will
//                                                               assert global precharge. If 0, it will preserve the last
//                                                               value from a real command or setvoltages request.
//     framegen_req                   1       6 RW   0x0         The rising edge of this bit (program to 0, then to 1) queues
//                                                               a request to generate framegen_count chip data frames from
//                                                               phase framegen_phase. This request will be processed when
//                                                               the userwave execution engine is idle because it has run out
//                                                               of ordinary commands to run. Status is reported in
//                                                               LVDS_USERWAVE_STATUS1_framegen_remaining. NOTE: The request
//                                                               will trigger on any underrun, whether intentional or not, so
//                                                               for robustness, software should defer queueing a request
//                                                               until it knows it is done feeding commands to the userwave
//                                                               ring buffer.
//     framegen_phase                 1       7 RW   0x0         Phase of generated data frames.
//     framegen_count                 8   15:08 RW   0x0         Number of data frames to generate.
//     framegen_cid                   16  31:16 RW   0x0         Characterization ID of generated data frames.
//
#define LVDS_USERWAVE_CTL                                            0x0000000000040200ULL
#define LVDS_USERWAVE_CTL_enable_fetch                               0x0100000000040200ULL
#define LVDS_USERWAVE_CTL_flush                                      0x0101000000040200ULL
#define LVDS_USERWAVE_CTL_halt_request                               0x0102000000040200ULL
#define LVDS_USERWAVE_CTL_setvoltages_req                            0x0103000000040200ULL
#define LVDS_USERWAVE_CTL_precharge_while_idle                       0x0104000000040200ULL
#define LVDS_USERWAVE_CTL_framegen_req                               0x0106000000040200ULL
#define LVDS_USERWAVE_CTL_framegen_phase                             0x0107000000040200ULL
#define LVDS_USERWAVE_CTL_framegen_count                             0x0808000000040200ULL
#define LVDS_USERWAVE_CTL_framegen_cid                               0x1010000000040200ULL

//
// Register:    LVDS_USERWAVE_HOST_BYTES_WRITTEN
// Description: Userwave DMA ring buffer management Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     count                          32  31:00 RW   0x0         Number of bytes host has written to the userwave DMA ring
//                                                               buffer since last reset or flush. See spec for details.
//
#define LVDS_USERWAVE_HOST_BYTES_WRITTEN                             0x0000000000040204ULL
#define LVDS_USERWAVE_HOST_BYTES_WRITTEN_count                       0x2000000000040204ULL

//
// Register:    LVDS_USERWAVE_FPGA_BYTES_READ
// Description: Userwave DMA ring buffer management Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     count                          32  31:00 RO   0x0         Number of bytes FPGA has read from the userwave DMA ring
//                                                               buffer since last reset or flush. See spec for details.
//
#define LVDS_USERWAVE_FPGA_BYTES_READ                                0x0000000000040208ULL
#define LVDS_USERWAVE_FPGA_BYTES_READ_count                          0x2000000000040208ULL

//
// Register:    LVDS_USERWAVE_STATUS1
// Description: Userwave status register 1
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     underrun                       1       0 RW1C 0x0         Reads 1 if userwave execution engine has run out of commands
//                                                               since last cleared, resulting in the execute engine running
//                                                               generated commands. Write 1 to clear.
//     fetch_halted                   1       1 RO   0x0         Reads 1 if userwave fetcher has halted because
//                                                               LVDS_USERWAVE_CTL_halt_request is 1 and the fetcher
//                                                               dispatched a command marked as a safe halting point. Clears
//                                                               when CTL_halt_request is cleared.
//     ex1_cmd_type                   1       2 RO   0x0         Reads 1 if the command in execute stage 1 is a generated
//                                                               command, 0 if it is from a real userwave command stream.
//     ex2_cmd_type                   1       3 RO   0x0         Reads 1 if the command in execute stage 2 is a generated
//                                                               command, 0 if it is from a real userwave command stream.
//     framegen_remaining             8   11:04 RO   0x0         When using the frame generator feature, reports the number
//                                                               of frames remaining. It is safe to request the generation of
//                                                               more frames (or restart normal userwave execution) when this
//                                                               field counts down to 0.
//     setvoltages_req_queued         1      12 RO   0x0         Reads 1 while a request to set voltages has been queued but
//                                                               not yet processed.
//
#define LVDS_USERWAVE_STATUS1                                        0x000000000004020cULL
#define LVDS_USERWAVE_STATUS1_underrun                               0x010000000004020cULL
#define LVDS_USERWAVE_STATUS1_fetch_halted                           0x010100000004020cULL
#define LVDS_USERWAVE_STATUS1_ex1_cmd_type                           0x010200000004020cULL
#define LVDS_USERWAVE_STATUS1_ex2_cmd_type                           0x010300000004020cULL
#define LVDS_USERWAVE_STATUS1_framegen_remaining                     0x080400000004020cULL
#define LVDS_USERWAVE_STATUS1_setvoltages_req_queued                 0x010c00000004020cULL

//
// Register:    LVDS_USERWAVE_STATUS2
// Description: Userwave status register 2 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     current_cmd_index              32  31:00 RO   0xffffffff  Returns the index field of the currently executing command.
//
#define LVDS_USERWAVE_STATUS2                                        0x0000000000040210ULL
#define LVDS_USERWAVE_STATUS2_current_cmd_index                      0x2000000000040210ULL

//
// Register:    LVDS_USERWAVE_CTL2
// Description: Userwave Control2 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     max_prefetch_depth             9   08:00 RW   0x100       Sets the maximum number of userwave commands to prefetch.
//                                                               Legal range is 1 to 256.
//
#define LVDS_USERWAVE_CTL2                                           0x0000000000040214ULL
#define LVDS_USERWAVE_CTL2_max_prefetch_depth                        0x0900000000040214ULL

//
// Register:    LVDS_DAC_U58_A_B
// Description: DAC U58 channels A and B Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     vouta_vpre1_a                  16  15:00 RW   0x0         Set DAC U58 channel A, board signal VPRE1_A. This is a
//                                                               userwave controlled channel; value is only sent to the DAC
//                                                               when the userwave engine processes a setvoltage request.
//     voutb_vpre1_b                  16  31:16 RW   0x0         Set DAC U58 channel B, board signal VPRE1_B. This is a
//                                                               userwave controlled channel; value is only sent to the DAC
//                                                               when the userwave engine processes a setvoltage request.
//
#define LVDS_DAC_U58_A_B                                             0x0000000000040240ULL
#define LVDS_DAC_U58_A_B_vouta_vpre1_a                               0x1000000000040240ULL
#define LVDS_DAC_U58_A_B_voutb_vpre1_b                               0x1010000000040240ULL

//
// Register:    LVDS_DAC_U58_C_D
// Description: DAC U58 channels C and D Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     voutc_liq_a                    16  15:00 RW   0x0         Set DAC U58 channel C, board signal LIQ_A. This is a
//                                                               userwave controlled channel; value is only sent to the DAC
//                                                               when the userwave engine processes a setvoltage request.
//     voutd_liq_b                    16  31:16 RW   0x0         Set DAC U58 channel D, board signal LIQ_B. This is a
//                                                               userwave controlled channel; value is only sent to the DAC
//                                                               when the userwave engine processes a setvoltage request.
//
#define LVDS_DAC_U58_C_D                                             0x0000000000040244ULL
#define LVDS_DAC_U58_C_D_voutc_liq_a                                 0x1000000000040244ULL
#define LVDS_DAC_U58_C_D_voutd_liq_b                                 0x1010000000040244ULL

//
// Register:    LVDS_DAC_U58_E_F
// Description: DAC U58 channels E and F Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     voute_wpump2_ctl               16  15:00 RW   0x3333      Set DAC U58 channel E, board signal WPUMP2_CTL.
//     voutf                          16  31:16 RW   0x0         Set DAC U58 channel F.
//
#define LVDS_DAC_U58_E_F                                             0x0000000000040248ULL
#define LVDS_DAC_U58_E_F_voute_wpump2_ctl                            0x1000000000040248ULL
#define LVDS_DAC_U58_E_F_voutf                                       0x1010000000040248ULL

//
// Register:    LVDS_DAC_U58_G_H
// Description: DAC U58 channels G and H Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     voutg                          16  15:00 RW   0x0         Set DAC U58 channel G.
//     vouth                          16  31:16 RW   0x0         Set DAC U58 channel H.
//
#define LVDS_DAC_U58_G_H                                             0x000000000004024cULL
#define LVDS_DAC_U58_G_H_voutg                                       0x100000000004024cULL
#define LVDS_DAC_U58_G_H_vouth                                       0x101000000004024cULL

//
// Register:    LVDS_DAC_U61_A_B
// Description: DAC U61 channels A and B Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     vouta_vb                       16  15:00 RW   0x0         Set DAC U61 channel A, board signal VB.
//     voutb_vpre2_a                  16  31:16 RW   0x0         Set DAC U61 channel B, board signal VPRE2_A. This is a
//                                                               userwave controlled channel; value is only sent to the DAC
//                                                               when the userwave engine processes a setvoltage request.
//
#define LVDS_DAC_U61_A_B                                             0x0000000000040250ULL
#define LVDS_DAC_U61_A_B_vouta_vb                                    0x1000000000040250ULL
#define LVDS_DAC_U61_A_B_voutb_vpre2_a                               0x1010000000040250ULL

//
// Register:    LVDS_DAC_U61_C_D
// Description: DAC U61 channels C and D Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     voutc_vpre2_b                  16  15:00 RW   0x0         Set DAC U61 channel C, board signal VPRE2_B. This is a
//                                                               userwave controlled channel; value is only sent to the DAC
//                                                               when the userwave engine processes a setvoltage request.
//     voutd_refp_a                   16  31:16 RW   0x0         Set DAC U61 channel D, board signal REFP_A. This is a
//                                                               userwave controlled channel; value is only sent to the DAC
//                                                               when the userwave engine processes a setvoltage request.
//
#define LVDS_DAC_U61_C_D                                             0x0000000000040254ULL
#define LVDS_DAC_U61_C_D_voutc_vpre2_b                               0x1000000000040254ULL
#define LVDS_DAC_U61_C_D_voutd_refp_a                                0x1010000000040254ULL

//
// Register:    LVDS_DAC_U61_E_F
// Description: DAC U61 channels E and F Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     voute_refp_b                   16  15:00 RW   0x0         Set DAC U61 channel E, board signal REFP_B. This is a
//                                                               userwave controlled channel; value is only sent to the DAC
//                                                               when the userwave engine processes a setvoltage request.
//     voutf_wpump1_ctl               16  31:16 RW   0x3333      Set DAC U61 channel F, board signal WPUMP1_CTL.
//
#define LVDS_DAC_U61_E_F                                             0x0000000000040258ULL
#define LVDS_DAC_U61_E_F_voute_refp_b                                0x1000000000040258ULL
#define LVDS_DAC_U61_E_F_voutf_wpump1_ctl                            0x1010000000040258ULL

//
// Register:    LVDS_DAC_U61_G_H
// Description: DAC U61 channels G and H
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     voutg_refn_a                   16  15:00 RW   0x0         Set DAC U61 channel G, board signal REFN_A. This is a
//                                                               userwave controlled channel; value is only sent to the DAC
//                                                               when the userwave engine processes a setvoltage request.
//     vouth_refn_b                   16  31:16 RW   0x0         Set DAC U61 channel H, board signal REFN_B. This is a
//                                                               userwave controlled channel; value is only sent to the DAC
//                                                               when the userwave engine processes a setvoltage request..
//
#define LVDS_DAC_U61_G_H                                             0x000000000004025cULL
#define LVDS_DAC_U61_G_H_voutg_refn_a                                0x100000000004025cULL
#define LVDS_DAC_U61_G_H_vouth_refn_b                                0x101000000004025cULL

//
// Register:    LVDS_DAC_SWITCHES
// Description: Analog voltage switch settings Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     vpretop_sw                     1       0 RW   0x0         This value will be copied to VPRETOP_SW (aka VPRE1_SW) when
//                                                               the userwave engine processes a setvoltages request.
//     vprebot_sw                     1       1 RW   0x0         This value will be copied to VPREBOT_SW (aka VPRE2_SW) when
//                                                               the userwave engine processes a setvoltages request.
//     refp_sw                        1       2 RW   0x0         This value will be copied to REFP_SW when the userwave
//                                                               engine processes a setvoltages request.
//     refn_sw                        1       3 RW   0x0         This value will be copied to REFN_SW when the userwave
//                                                               engine processes a setvoltages request.
//     liq_sw                         1       4 RW   0x0         This value will be copied to LIQ_SW when the userwave engine
//                                                               processes a setvoltages request.
//     glb_pre_sw                     1       5 RW   0x0         This value will be copied to the global precharge switch
//                                                               when the userwave engine processes a setvoltages request.
//
#define LVDS_DAC_SWITCHES                                            0x0000000000040260ULL
#define LVDS_DAC_SWITCHES_vpretop_sw                                 0x0100000000040260ULL
#define LVDS_DAC_SWITCHES_vprebot_sw                                 0x0101000000040260ULL
#define LVDS_DAC_SWITCHES_refp_sw                                    0x0102000000040260ULL
#define LVDS_DAC_SWITCHES_refn_sw                                    0x0103000000040260ULL
#define LVDS_DAC_SWITCHES_liq_sw                                     0x0104000000040260ULL
#define LVDS_DAC_SWITCHES_glb_pre_sw                                 0x0105000000040260ULL

//
// Register:    LVDS_CTL1
// Description: LVDS debug control 1 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     reset_lvds                     1       0 RW   0x1         LVDS soft reset
//     detect_sel                     4   04:01 RW   0x1         Detect counter select. 0: Framer EOF 1: Compact EOF 2:
//                                                               compact2muxddr0_wready_last 3: compact2muxddr1_wready_last
//                                                               4: lvds2ddr0_wrreq 5: lvds2ddr1_wrreq_cnt
//
#define LVDS_CTL1                                                    0x0000000000040280ULL
#define LVDS_CTL1_reset_lvds                                         0x0100000000040280ULL
#define LVDS_CTL1_detect_sel                                         0x0401000000040280ULL

//
// Register:    LVDS_PA_STATUS1
// Description: Phased-array control status register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     sync_cnt                       32  31:00 RO   0x0         Chip-generated sync pulse counter
//
#define LVDS_PA_STATUS1                                              0x0000000000040284ULL
#define LVDS_PA_STATUS1_sync_cnt                                     0x2000000000040284ULL

//
// Register:    LVDS_DETECT_FRAME_CNT
// Description: LVDS frame detected count Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     count                          32  31:00 RO   0x0         Frames detected by LVDS.
//
#define LVDS_DETECT_FRAME_CNT                                        0x0000000000040298ULL
#define LVDS_DETECT_FRAME_CNT_count                                  0x2000000000040298ULL

//
// Register:    LVDS_FIFO_STATUS1
// Description: LVDS FIFO health status register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     uwexec_dropped_framedescriptor 1       0 RW1C 0x0         1 if error has occurred since last clear. Write 1 to clear.
//     uwfetch_axirderr               1       1 RW1C 0x0         1 if error has occurred since last clear. Write 1 to clear.
//     uwfetch_axirresp               2   03:02 RO   0x0         When LVDS_FIFO_STATUS1_uwfetch_axirderr transitions from 0
//                                                               to 1, this field captures the associated RRESP (read
//                                                               response) code.
//     recmap_phase_fifo_overflow     1       4 RW1C 0x0         1 if error has occurred since last clear. Write 1 to clear.
//     recmap_axirderr                1       5 RW1C 0x0         1 if error has occurred since last clear. Write 1 to clear.
//     recmap_axirresp                2   07:06 RO   0x0         When LVDS_FIFO_STATUS1_recmap_axirderr transitions from 0 to
//                                                               1, this field captures the associated RRESP (read response)
//                                                               code.
//
#define LVDS_FIFO_STATUS1                                            0x0000000000040300ULL
#define LVDS_FIFO_STATUS1_uwexec_dropped_framedescriptor             0x0100000000040300ULL
#define LVDS_FIFO_STATUS1_uwfetch_axirderr                           0x0101000000040300ULL
#define LVDS_FIFO_STATUS1_uwfetch_axirresp                           0x0202000000040300ULL
#define LVDS_FIFO_STATUS1_recmap_phase_fifo_overflow                 0x0104000000040300ULL
#define LVDS_FIFO_STATUS1_recmap_axirderr                            0x0105000000040300ULL
#define LVDS_FIFO_STATUS1_recmap_axirresp                            0x0206000000040300ULL

//
// Register:    LVDS_IO_CTL1
// Description: LVDS Idle Sync Pattern Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     enable_ncap                    1       8 RW   0x0         Enable ncap on sensor chip.
//
#define LVDS_IO_CTL1                                                 0x0000000000040400ULL
#define LVDS_IO_CTL1_enable_ncap                                     0x0108000000040400ULL

//
// Register:    LVDS_DELAY_READ
// Description: Read delay line and other status values from a selected LVDS lane
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     delay                          9   08:00 RO   0x0         Delay tap value for the LVDS lane specified by the lanesel
//                                                               field.
//     delay_ext                      9   18:10 RO   0x0         Extended delay tap value for the LVDS lane specified by the
//                                                               lanesel field.
//     fifo_empty                     1      20 RO   0x0         Current FIFO empty status for the LVDS lane specified by the
//                                                               lanesel field.
//     fifo_rd_en                     1      21 RO   0x0         Current value of FIFO read enable for the LVDS lane
//                                                               specified by the lanesel field.
//     lanesel                        6   31:26 RW   0x0         Sets the lane number to read out.
//
#define LVDS_DELAY_READ                                              0x0000000000040500ULL
#define LVDS_DELAY_READ_delay                                        0x0900000000040500ULL
#define LVDS_DELAY_READ_delay_ext                                    0x090a000000040500ULL
#define LVDS_DELAY_READ_fifo_empty                                   0x0114000000040500ULL
#define LVDS_DELAY_READ_fifo_rd_en                                   0x0115000000040500ULL
#define LVDS_DELAY_READ_lanesel                                      0x061a000000040500ULL

//
// Register:    LVDS_DELAY_WRITE
// Description: Controls the process of writing delay line values to a variable number of LVDS lanes.
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     delay                          9   08:00 RW   0x0         The delay tap value to be written to the lanes specified in
//                                                               the write mask.
//     delay_ext                      9   18:10 RW   0x0         The extended delay tap value to be written to the lanes
//                                                               specified in the write mask.
//     dly_ready                      1      20 RO   0x0         Reads 1 while all bitslices report DLY ready. This
//                                                               information is reported in more detail in HSSIO registers.
//     vtc_ready                      1      21 RO   0x0         Reads 1 while all bitslices report VTC ready. This
//                                                               information is reported in more detail in HSSIO registers.
//     ready_for_write                1      30 RO   0x0         Reads 1 while the delay write state machine is ready to
//                                                               process a request. Attempts to write while not ready are
//                                                               ignored. State machine cannot become ready until both
//                                                               vtc_ready and dly_ready are 1.
//     write                          1      31 RW   0x0         The rising edge of this bit requests the FPGA to write the
//                                                               delay values specified in the delay and delay_ext fields to
//                                                               the lanes specified in LVDS_DELAY_WRITE_MASK_LO/HI. If the
//                                                               ready_for_write filed is not 1, the request will be ignored.
//
#define LVDS_DELAY_WRITE                                             0x0000000000040504ULL
#define LVDS_DELAY_WRITE_delay                                       0x0900000000040504ULL
#define LVDS_DELAY_WRITE_delay_ext                                   0x090a000000040504ULL
#define LVDS_DELAY_WRITE_dly_ready                                   0x0114000000040504ULL
#define LVDS_DELAY_WRITE_vtc_ready                                   0x0115000000040504ULL
#define LVDS_DELAY_WRITE_ready_for_write                             0x011e000000040504ULL
#define LVDS_DELAY_WRITE_write                                       0x011f000000040504ULL

//
// Register:    LVDS_DELAY_WRITE_MASK_LO
// Description: Controls whether lanes 0 to 31 are written when a write is initiated by LVDS_DELAY_WRITE.
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     mask                           32  31:00 RW   0x0         Bits 31:0 of the LVDS delay line write mask.
//
#define LVDS_DELAY_WRITE_MASK_LO                                     0x0000000000040508ULL
#define LVDS_DELAY_WRITE_MASK_LO_mask                                0x2000000000040508ULL

//
// Register:    LVDS_DELAY_WRITE_MASK_HI
// Description: Controls whether lanes 32 to 63 are written when a write is initiated by LVDS_DELAY_WRITE.
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     mask                           32  31:00 RW   0x0         Bits 63:32 of the LVDS delay line write mask.
//
#define LVDS_DELAY_WRITE_MASK_HI                                     0x000000000004050cULL
#define LVDS_DELAY_WRITE_MASK_HI_mask                                0x200000000004050cULL

//
// Register:    LVDS_USERWAVE2PCIE_AXIMON1
// Description: AXI Monitor 1 - Queue depth counters and overflow/underflow flags
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     ar_qd                          8   07:00 RO   0x0         Returns the current queue depth of the AR channel.
//     aw_qd                          8   15:08 RO   0x0         Returns the current queue depth of the AW channel.
//     w_qd                           8   23:16 RO   0x0         Returns the current queue depth of the W channel.
//     ar_qd_ovf                      1      24 RW1C 0x0         1 if the counter overflowed. Write 1 to clear.
//     ar_qd_uf                       1      25 RW1C 0x0         1 if the counter underflowed. Write 1 to clear.
//     aw_qd_ovf                      1      26 RW1C 0x0         1 if the counter overflowed. Write 1 to clear.
//     aw_qd_uf                       1      27 RW1C 0x0         1 if the counter underflowed. Write 1 to clear.
//     w_qd_ovf                       1      28 RW1C 0x0         1 if the counter overflowed. Write 1 to clear.
//     w_qd_uf                        1      29 RW1C 0x0         1 if the counter underflowed. Write 1 to clear.
//     reset_ctrs                     1      31 RW   0x0         While 1, queue depth and queue depth highwater counters are
//                                                               reset to 0.
//
#define LVDS_USERWAVE2PCIE_AXIMON1                                   0x0000000000041000ULL
#define LVDS_USERWAVE2PCIE_AXIMON1_ar_qd                             0x0800000000041000ULL
#define LVDS_USERWAVE2PCIE_AXIMON1_aw_qd                             0x0808000000041000ULL
#define LVDS_USERWAVE2PCIE_AXIMON1_w_qd                              0x0810000000041000ULL
#define LVDS_USERWAVE2PCIE_AXIMON1_ar_qd_ovf                         0x0118000000041000ULL
#define LVDS_USERWAVE2PCIE_AXIMON1_ar_qd_uf                          0x0119000000041000ULL
#define LVDS_USERWAVE2PCIE_AXIMON1_aw_qd_ovf                         0x011a000000041000ULL
#define LVDS_USERWAVE2PCIE_AXIMON1_aw_qd_uf                          0x011b000000041000ULL
#define LVDS_USERWAVE2PCIE_AXIMON1_w_qd_ovf                          0x011c000000041000ULL
#define LVDS_USERWAVE2PCIE_AXIMON1_w_qd_uf                           0x011d000000041000ULL
#define LVDS_USERWAVE2PCIE_AXIMON1_reset_ctrs                        0x011f000000041000ULL

//
// Register:    LVDS_USERWAVE2PCIE_AXIMON2
// Description: AXI Monitor 2 - Queue depth counter high water marks, read/write error reporting
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     ar_qd_highwater                8   07:00 RO   0x0         Returns the maximum observed queue depth of the AR channel.
//     aw_qd_highwater                8   15:08 RO   0x0         Returns the maximum observed queue depth of the AW channel.
//     w_qd_highwater                 8   23:16 RO   0x0         Returns the maximum observed queue depth of the W channel.
//     rderr                          1      24 RW1C 0x0         1 if an AXI read error occurred. Write 1 to clear.
//     rresp                          2   26:25 RO   0x0         Records the RRESP code observed during the last read error.
//     wrerr                          1      28 RW1C 0x0         1 if an AXI write error occurred. Write 1 to clear.
//     bresp                          2   30:29 RO   0x0         Records the BRESP code observed during the last write error.
//
#define LVDS_USERWAVE2PCIE_AXIMON2                                   0x0000000000041004ULL
#define LVDS_USERWAVE2PCIE_AXIMON2_ar_qd_highwater                   0x0800000000041004ULL
#define LVDS_USERWAVE2PCIE_AXIMON2_aw_qd_highwater                   0x0808000000041004ULL
#define LVDS_USERWAVE2PCIE_AXIMON2_w_qd_highwater                    0x0810000000041004ULL
#define LVDS_USERWAVE2PCIE_AXIMON2_rderr                             0x0118000000041004ULL
#define LVDS_USERWAVE2PCIE_AXIMON2_rresp                             0x0219000000041004ULL
#define LVDS_USERWAVE2PCIE_AXIMON2_wrerr                             0x011c000000041004ULL
#define LVDS_USERWAVE2PCIE_AXIMON2_bresp                             0x021d000000041004ULL

//
// Register:    LVDS_COMPACT2MEM_AXIMON1
// Description: AXI Monitor 1 - Queue depth counters and overflow/underflow flags
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     ar_qd                          8   07:00 RO   0x0         Returns the current queue depth of the AR channel.
//     aw_qd                          8   15:08 RO   0x0         Returns the current queue depth of the AW channel.
//     w_qd                           8   23:16 RO   0x0         Returns the current queue depth of the W channel.
//     ar_qd_ovf                      1      24 RW1C 0x0         1 if the counter overflowed. Write 1 to clear.
//     ar_qd_uf                       1      25 RW1C 0x0         1 if the counter underflowed. Write 1 to clear.
//     aw_qd_ovf                      1      26 RW1C 0x0         1 if the counter overflowed. Write 1 to clear.
//     aw_qd_uf                       1      27 RW1C 0x0         1 if the counter underflowed. Write 1 to clear.
//     w_qd_ovf                       1      28 RW1C 0x0         1 if the counter overflowed. Write 1 to clear.
//     w_qd_uf                        1      29 RW1C 0x0         1 if the counter underflowed. Write 1 to clear.
//     reset_ctrs                     1      31 RW   0x0         While 1, queue depth and queue depth highwater counters are
//                                                               reset to 0.
//
#define LVDS_COMPACT2MEM_AXIMON1                                     0x0000000000041010ULL
#define LVDS_COMPACT2MEM_AXIMON1_ar_qd                               0x0800000000041010ULL
#define LVDS_COMPACT2MEM_AXIMON1_aw_qd                               0x0808000000041010ULL
#define LVDS_COMPACT2MEM_AXIMON1_w_qd                                0x0810000000041010ULL
#define LVDS_COMPACT2MEM_AXIMON1_ar_qd_ovf                           0x0118000000041010ULL
#define LVDS_COMPACT2MEM_AXIMON1_ar_qd_uf                            0x0119000000041010ULL
#define LVDS_COMPACT2MEM_AXIMON1_aw_qd_ovf                           0x011a000000041010ULL
#define LVDS_COMPACT2MEM_AXIMON1_aw_qd_uf                            0x011b000000041010ULL
#define LVDS_COMPACT2MEM_AXIMON1_w_qd_ovf                            0x011c000000041010ULL
#define LVDS_COMPACT2MEM_AXIMON1_w_qd_uf                             0x011d000000041010ULL
#define LVDS_COMPACT2MEM_AXIMON1_reset_ctrs                          0x011f000000041010ULL

//
// Register:    LVDS_COMPACT2MEM_AXIMON2
// Description: AXI Monitor 2 - Queue depth counter high water marks, read/write error reporting
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     ar_qd_highwater                8   07:00 RO   0x0         Returns the maximum observed queue depth of the AR channel.
//     aw_qd_highwater                8   15:08 RO   0x0         Returns the maximum observed queue depth of the AW channel.
//     w_qd_highwater                 8   23:16 RO   0x0         Returns the maximum observed queue depth of the W channel.
//     rderr                          1      24 RW1C 0x0         1 if an AXI read error occurred. Write 1 to clear.
//     rresp                          2   26:25 RO   0x0         Records the RRESP code observed during the last read error.
//     wrerr                          1      28 RW1C 0x0         1 if an AXI write error occurred. Write 1 to clear.
//     bresp                          2   30:29 RO   0x0         Records the BRESP code observed during the last write error.
//
#define LVDS_COMPACT2MEM_AXIMON2                                     0x0000000000041014ULL
#define LVDS_COMPACT2MEM_AXIMON2_ar_qd_highwater                     0x0800000000041014ULL
#define LVDS_COMPACT2MEM_AXIMON2_aw_qd_highwater                     0x0808000000041014ULL
#define LVDS_COMPACT2MEM_AXIMON2_w_qd_highwater                      0x0810000000041014ULL
#define LVDS_COMPACT2MEM_AXIMON2_rderr                               0x0118000000041014ULL
#define LVDS_COMPACT2MEM_AXIMON2_rresp                               0x0219000000041014ULL
#define LVDS_COMPACT2MEM_AXIMON2_wrerr                               0x011c000000041014ULL
#define LVDS_COMPACT2MEM_AXIMON2_bresp                               0x021d000000041014ULL

//
// Register:    LVDS_DEBUG_STATUS3
// Description: LVDS Debug Status3 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     pa_sync                        1       0 RW1C 0x0         Latches to 1 each time the FPGA self-synchronizes to the
//                                                               phased array sync pulse coming from the chip. If cleared
//                                                               after chip is powered up and configured for PA mode with
//                                                               external control, this bit should read 0 until the chip is
//                                                               reset or powered down or configured to an incompatible mode.
//                                                               Write 1 to clear.
//     uw_min_duration_violated       1       1 RW1C 0x0         Error flag indicating userwave engine has executed a command
//                                                               with a duration field that is smaller than the minimum
//                                                               supported time. Write 1 to clear.
//     uw_frame_hdr_dropped           1       2 RW1C 0x0         Error flag indicating userwave engine dropped a frame header
//                                                               due to backpressure. Write 1 to clear.
//
#define LVDS_DEBUG_STATUS3                                           0x0000000000042000ULL
#define LVDS_DEBUG_STATUS3_pa_sync                                   0x0100000000042000ULL
#define LVDS_DEBUG_STATUS3_uw_min_duration_violated                  0x0101000000042000ULL
#define LVDS_DEBUG_STATUS3_uw_frame_hdr_dropped                      0x0102000000042000ULL

//
// Register:    LVDS_DEBUG_STATUS4
// Description: LVDS Debug Status4 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     rs0_ctr                        32  31:00 RO   0x0         Increments by 1 each time userwave pulses RS0 signal to the
//                                                               chip. Resets to 0 while LVDS_DBG_CTL1_dbg_reset is 1.
//
#define LVDS_DEBUG_STATUS4                                           0x0000000000042004ULL
#define LVDS_DEBUG_STATUS4_rs0_ctr                                   0x2000000000042004ULL

//
// Register:    LVDS_DEBUG_STATUS5
// Description: LVDS Debug Status5 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     rs256_ctr                      32  31:00 RO   0x0         Increments by 1 each time userwave pulses RS256 signal to
//                                                               the chip. Resets to 0 while LVDS_DBG_CTL1_dbg_reset is 1.
//
#define LVDS_DEBUG_STATUS5                                           0x0000000000042008ULL
#define LVDS_DEBUG_STATUS5_rs256_ctr                                 0x2000000000042008ULL

//
// Register:    LVDS_DEBUG_STATUS6
// Description: LVDS Debug Status6 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     p0_fdesc_ctr                   32  31:00 RO   0x0         Increments by 1 each time userwave module sends a phase 0
//                                                               frame descriptor. Resets to 0 while LVDS_DBG_CTL1_dbg_reset
//                                                               is 1.
//
#define LVDS_DEBUG_STATUS6                                           0x000000000004200cULL
#define LVDS_DEBUG_STATUS6_p0_fdesc_ctr                              0x200000000004200cULL

//
// Register:    LVDS_DEBUG_STATUS7
// Description: LVDS Debug Status7 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     p1_fdesc_ctr                   32  31:00 RO   0x0         Increments by 1 each time userwave module sends a phase 1
//                                                               frame descriptor. Resets to 0 while LVDS_DBG_CTL1_dbg_reset
//                                                               is 1.
//
#define LVDS_DEBUG_STATUS7                                           0x0000000000042010ULL
#define LVDS_DEBUG_STATUS7_p1_fdesc_ctr                              0x2000000000042010ULL

//
// Register:    LVDS_DEBUG_STATUS10
// Description: LVDS Debug Status10 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     compact_frame_ctr              32  31:00 RO   0x0         Increments by 1 each time LVDS compactor module emits a
//                                                               frame. Resets to 0 while LVDS_DBG_CTL1_dbg_reset is 1.
//
#define LVDS_DEBUG_STATUS10                                          0x000000000004201cULL
#define LVDS_DEBUG_STATUS10_compact_frame_ctr                        0x200000000004201cULL

//
// Register:    LVDS_DEBUG_STATUS11
// Description: LVDS Debug Status11 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     framer_eof_ctr                 32  31:00 RO   0x0         Select lane with LVDS_DBG_CTL1_lane_sel. Each counter
//                                                               increments by 1 each time EOF happens in its lane. All lane
//                                                               counters are reset to 0 while LVDS_DBG_CTL1_dbg_reset is 1.
//
#define LVDS_DEBUG_STATUS11                                          0x0000000000042020ULL
#define LVDS_DEBUG_STATUS11_framer_eof_ctr                           0x2000000000042020ULL

//
// Register:    LVDS_SENSOREMU_REVISION
// Description: Sensor Emulator Revision
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     rev                            32  31:00 RO   0x1         Reports the revision level of the sensor emulator module.
//
#define LVDS_SENSOREMU_REVISION                                      0x0000000000044000ULL
#define LVDS_SENSOREMU_REVISION_rev                                  0x2000000000044000ULL

//
// Register:    LVDS_SENSOREMU_CFG1
// Description: Sensor Emulator Config 1
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     idle_sync_pattern              16  15:00 RW   0xf055      Sets the 16-bit LVDS idle pattern sent by the sensor
//                                                               emulator. Should match LVDS_IDLE_SYNC_PATTERN_pattern unless
//                                                               testing how the FPGA handles bad idle pattern.
//     sensoremu_en                   1      31 RW   0x0         Controls the MUX selecting whether sensor emulator or real
//                                                               chip LVDS data is sent to the FPGA LVDS data pipeline.
//                                                               0:real chip, 1:emulator. Note that this MUX also controls
//                                                               whether userwave gets its phased array sync signal from the
//                                                               chip or the emulator. If the chip and emulator are out of
//                                                               phase with each other, changing the MUX selection will set
//                                                               LVDS_DEBUG_STATUS3_pa_sync. After changing this field, it is
//                                                               good practice to wait 10ms or so to give the FPGA's
//                                                               synchronizing mechanism time to re-sync to the new sync
//                                                               pulse source, clear LVDS_DEBUG_STATUS3_pa_sync if needed,
//                                                               and only then proceed with other activity.
//
#define LVDS_SENSOREMU_CFG1                                          0x0000000000044004ULL
#define LVDS_SENSOREMU_CFG1_idle_sync_pattern                        0x1000000000044004ULL
#define LVDS_SENSOREMU_CFG1_sensoremu_en                             0x011f000000044004ULL

//
// Register:    LVDS_SENSOREMU_CFG2
// Description: Sensor Emulator Config 2
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     header_sync_pattern            32  31:00 RW   0xfaa0faa   Sets the 32-bit LVDS header sync pattern sent by the sensor
//                                                               emulator. Should match LVDS_HEADER_SYNC_PATTERN_pattern
//                                                               unless testing how the FPGA handles bad header sync pattern.
//
#define LVDS_SENSOREMU_CFG2                                          0x0000000000044008ULL
#define LVDS_SENSOREMU_CFG2_header_sync_pattern                      0x2000000000044008ULL

//
// Register:    LVDS_SENSOREMU_FIFO_LOAD_UPPER32
// Description: Sensor Emulator FIFO Load Upper 32
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     dat                            32  31:00 RW   0x0         Used in conjunction with either LVDS_SENSOREMU_FIFO0_LOAD or
//                                                               LVDS_SENSOREMU_FIFO1_LOAD when loading 64-bit words into
//                                                               FIFOs.
//
#define LVDS_SENSOREMU_FIFO_LOAD_UPPER32                             0x000000000004400cULL
#define LVDS_SENSOREMU_FIFO_LOAD_UPPER32_dat                         0x200000000004400cULL

//
// Register:    LVDS_SENSOREMU_FIFO0_LOAD
// Description: Sensor Emulator FIFO 0 Pattern Load
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     dat                            32  31:00 RW   0x0         Write to load one word into sensor emulator FIFO 0. If the
//                                                               sensor emulator is configured for 8-byte pattern width, the
//                                                               upper 32 bits are taken from
//                                                               LVDS_SENSOREMU_FIFO_LOAD_UPPER32.
//
#define LVDS_SENSOREMU_FIFO0_LOAD                                    0x0000000000044010ULL
#define LVDS_SENSOREMU_FIFO0_LOAD_dat                                0x2000000000044010ULL

//
// Register:    LVDS_SENSOREMU_FIFO1_LOAD
// Description: Sensor Emulator FIFO 1 Pattern Load
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     dat                            32  31:00 RW   0x0         Write to load one word into sensor emulator FIFO 1. If the
//                                                               sensor emulator is configured for 8-byte pattern width, the
//                                                               upper 32 bits are taken from
//                                                               LVDS_SENSOREMU_FIFO_LOAD_UPPER32.
//
#define LVDS_SENSOREMU_FIFO1_LOAD                                    0x0000000000044014ULL
#define LVDS_SENSOREMU_FIFO1_LOAD_dat                                0x2000000000044014ULL

//
// Register:    LVDS_SENSOREMU_FIFO_RESET
// Description: Sensor Emulator FIFO Reset Request
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     reset                          2   01:00 RW   0x0         Write a value to request reset of one or both sensor
//                                                               emulator FIFOs. If 0, no FIFOs will be reset. If 1, FIFO 0
//                                                               will be reset. If 2, FIFO 1 will be reset. If 3, both FIFOs
//                                                               will be reset.
//
#define LVDS_SENSOREMU_FIFO_RESET                                    0x0000000000044018ULL
#define LVDS_SENSOREMU_FIFO_RESET_reset                              0x0200000000044018ULL

//
// Register:    LVDS_SENSOREMU_FIFO_STATUS1
// Description: Sensor Emulator FIFO Status 1
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     f0_ready                       1       0 RO   0x0         Reads 1 while FIFO 0 is ready for use, 0 while in reset.
//     f1_ready                       1       1 RO   0x0         Reads 1 while FIFO 1 is ready for use, 0 while in reset.
//     activefifo                     2   03:02 RO   0x0         Reports which of the FIFOs is active, if any.
//     patternwidth                   4   07:04 RO   0x0         Reports the sensor emulator's pattern width in bytes.
//
#define LVDS_SENSOREMU_FIFO_STATUS1                                  0x000000000004401cULL
#define LVDS_SENSOREMU_FIFO_STATUS1_f0_ready                         0x010000000004401cULL
#define LVDS_SENSOREMU_FIFO_STATUS1_f1_ready                         0x010100000004401cULL
#define LVDS_SENSOREMU_FIFO_STATUS1_activefifo                       0x020200000004401cULL
#define LVDS_SENSOREMU_FIFO_STATUS1_patternwidth                     0x040400000004401cULL

//
// Register:    LVDS_SENSOREMU_FIFO_STATUS2
// Description: Sensor Emulator FIFO Status 2
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     f0_count                       32  31:00 RO   0x0         Reports the number of entries stored in FIFO 0.
//
#define LVDS_SENSOREMU_FIFO_STATUS2                                  0x0000000000044020ULL
#define LVDS_SENSOREMU_FIFO_STATUS2_f0_count                         0x2000000000044020ULL

//
// Register:    LVDS_SENSOREMU_FIFO_STATUS3
// Description: Sensor Emulator FIFO Status 3
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     f1_count                       32  31:00 RO   0x0         Reports the number of entries stored in FIFO 1.
//
#define LVDS_SENSOREMU_FIFO_STATUS3                                  0x0000000000044024ULL
#define LVDS_SENSOREMU_FIFO_STATUS3_f1_count                         0x2000000000044024ULL

//
// Register:    LVDS_SENSOREMU_STARTSTOP
// Description: Sensor Emulator Start/Stop Request
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     cmd                            2   01:00 RW   0x0         Write 0 to request stop, 1 to request start of FIFO 0, or 2
//                                                               to request start of FIFO 1. Do not write 3, behavior is
//                                                               undefined.
//
#define LVDS_SENSOREMU_STARTSTOP                                     0x000000000004402cULL
#define LVDS_SENSOREMU_STARTSTOP_cmd                                 0x020000000004402cULL

//
// Register:    LVDS_SENSOREMU_HARDSTOP
// Description: Sensor Emulator Hard Stop Request
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     hardstop                       32  31:00 RW   0x0         Write any value to request hard stop of sensor emulator.
//
#define LVDS_SENSOREMU_HARDSTOP                                      0x0000000000044030ULL
#define LVDS_SENSOREMU_HARDSTOP_hardstop                             0x2000000000044030ULL

//
// Register:    LVDS_ALOG_CFG
// Description: LVDS DMA Address Log Configuration
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     chan                           8   07:00 RW   0x0         Selects which DMA channel to monitor.
//     port                           3   10:08 RW   0x0         Selects which DMA address generator port to monitor. 0=phase
//                                                               1 DDR write, 1=phase 0 DDR write, 2=phase 1 RBM read,
//                                                               3=phase 0 RBM read, 4=userwave read.
//     flush                          1      11 RW   0x0         Set to 1 to flush the address log FIFO.
//
#define LVDS_ALOG_CFG                                                0x0000000000047100ULL
#define LVDS_ALOG_CFG_chan                                           0x0800000000047100ULL
#define LVDS_ALOG_CFG_port                                           0x0308000000047100ULL
#define LVDS_ALOG_CFG_flush                                          0x010b000000047100ULL

//
// Register:    LVDS_ALOG_DATA
// Description: LVDS DMA Address Log Data Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     dat                            32  31:00 RO   0x0         Read this register to read and pop an entry from the address
//                                                               log FIFO. Bit 31: valid (if 0, FIFO was empty at time of
//                                                               read). Bit 30: Reads 1 if FIFO overflowed since the previous
//                                                               read. Bits 29:0: bits 41:12 of a logged address if bit 31 is
//                                                               1, otherwise meaningless.
//
#define LVDS_ALOG_DATA                                               0x0000000000047104ULL
#define LVDS_ALOG_DATA_dat                                           0x2000000000047104ULL

//
// Register:    LVDS_DBG_CTL1
// Description: LVDS DEBUG Control 1 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     dbg_reset                      1       0 RW   0x0         Reset the debug status.
//     lane_sel                       6   13:08 RW   0x0         Some LVDS debug counters are per-lane. This field selects
//                                                               which lane's counters are connected to the register
//                                                               interface for readout.
//
#define LVDS_DBG_CTL1                                                0x0000000000047f00ULL
#define LVDS_DBG_CTL1_dbg_reset                                      0x0100000000047f00ULL
#define LVDS_DBG_CTL1_lane_sel                                       0x0608000000047f00ULL

//
// Register:    LVDS_DBG_STATUS1
// Description: LVDS DBG STATUS1 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     lane_rowbuf_overflow_lo        32  31:00 RW1C 0x0         Bits read 1 if LVDS data reorder block has experienced an
//                                                               overflow in the corresponding LVDS lane. Write 1 to a bit to
//                                                               clear it. (LVDS Lanes 31:0)
//
#define LVDS_DBG_STATUS1                                             0x0000000000047f10ULL
#define LVDS_DBG_STATUS1_lane_rowbuf_overflow_lo                     0x2000000000047f10ULL

//
// Register:    LVDS_DBG_STATUS2
// Description: LVDS DBG STATUS2 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     lane_rowbuf_overflow_hi        32  31:00 RW1C 0x0         Bits read 1 if LVDS data reorder block has experienced an
//                                                               overflow in the corresponding LVDS lane. Write 1 to a bit to
//                                                               clear it. (LVDS Lanes 63:32)
//
#define LVDS_DBG_STATUS2                                             0x0000000000047f14ULL
#define LVDS_DBG_STATUS2_lane_rowbuf_overflow_hi                     0x2000000000047f14ULL

//
// Register:    LVDS_DBG_STATUS3
// Description: LVDS DBG STATUS3 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     short_row_lo                   32  31:00 RW1C 0x0         Bits read 1 if the LVDS framer for the corresponding lane
//                                                               emitted a short row (less than 256 bytes). Write 1 to a bit
//                                                               to clear it. (LVDS Lanes 31:0)
//
#define LVDS_DBG_STATUS3                                             0x0000000000047f18ULL
#define LVDS_DBG_STATUS3_short_row_lo                                0x2000000000047f18ULL

//
// Register:    LVDS_DBG_STATUS4
// Description: LVDS DBG STATUS4 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     short_row_hi                   32  31:00 RW1C 0x0         Bits read 1 if the LVDS framer for the corresponding lane
//                                                               emitted a short row (less than 256 bytes). Write 1 to a bit
//                                                               to clear it. (LVDS Lanes 63:32)
//
#define LVDS_DBG_STATUS4                                             0x0000000000047f1cULL
#define LVDS_DBG_STATUS4_short_row_hi                                0x2000000000047f1cULL

//
// Register:    LVDS_DBG_STATUS5
// Description: LVDS DBG STATUS5 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     pdbank_rowbuf_overflow         8   07:00 RW1C 0x0         Bits read 1 if the corresponding pdbank row buffer has
//                                                               reported overflow. Write 1 to a bit to clear it. (pdbanks
//                                                               7:0)
//     pdbank_rowbuf_underflow        8   15:08 RW1C 0x0         Bits read 1 if the corresponding pdbank row buffer has
//                                                               reported underflow. Write 1 to a bit to clear it. (pdbanks
//                                                               7:0)
//     pdbank_rowbuf_backpressure     8   23:16 RW1C 0x0         Bits read 1 if the corresponding pdbank row buffer has
//                                                               reported backpressure. Write 1 to a bit to clear it.
//                                                               (pdbanks 7:0)
//     reordered_chip_backpressure    1      24 RW1C 0x0         Reads 1 if the LVDS reorder module has seen backpressure at
//                                                               its output port. Write 1 to clear.
//
#define LVDS_DBG_STATUS5                                             0x0000000000047f20ULL
#define LVDS_DBG_STATUS5_pdbank_rowbuf_overflow                      0x0800000000047f20ULL
#define LVDS_DBG_STATUS5_pdbank_rowbuf_underflow                     0x0808000000047f20ULL
#define LVDS_DBG_STATUS5_pdbank_rowbuf_backpressure                  0x0810000000047f20ULL
#define LVDS_DBG_STATUS5_reordered_chip_backpressure                 0x0118000000047f20ULL

//
// Register:    LVDS_DBG_STATUS6
// Description: LVDS DBG STATUS6 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     eof_err_lo                     32  31:00 RW1C 0x0         Bits read 1 if LVDS data reorder block has reported EOF
//                                                               error in the corresponding byte lane. Write 1 to a bit to
//                                                               clear it. (byte lanes 31:0)
//
#define LVDS_DBG_STATUS6                                             0x0000000000047f24ULL
#define LVDS_DBG_STATUS6_eof_err_lo                                  0x2000000000047f24ULL

//
// Register:    LVDS_DBG_STATUS7
// Description: LVDS DBG STATUS7 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     eof_err_hi                     32  31:00 RW1C 0x0         Bits read 1 if LVDS data reorder block has reported EOF
//                                                               error in the corresponding byte lane. Write 1 to a bit to
//                                                               clear it. (byte lanes 63:32)
//
#define LVDS_DBG_STATUS7                                             0x0000000000047f28ULL
#define LVDS_DBG_STATUS7_eof_err_hi                                  0x2000000000047f28ULL

//
// Register:    LVDS_DBG_STATUS8
// Description: LVDS DBG STATUS8 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     lvds_dp_backpressure           1       0 RW1C 0x0         Reads 1 if LVDS has seen backpressure from DP. Write 1 to
//                                                               clear.
//     ph_fifo_overflow               1       1 RW1C 0x0         Reads 1 if phase fifo overflow. Write 1 to clear.
//     hdr_fifo_overflow              1       2 RW1C 0x0         Reads 1 if header fifo overflow. Write 1 to clear.
//
#define LVDS_DBG_STATUS8                                             0x0000000000047f2cULL
#define LVDS_DBG_STATUS8_lvds_dp_backpressure                        0x0100000000047f2cULL
#define LVDS_DBG_STATUS8_ph_fifo_overflow                            0x0101000000047f2cULL
#define LVDS_DBG_STATUS8_hdr_fifo_overflow                           0x0102000000047f2cULL

//
// Register:    DP_CTL1
// Description: Data Path Configuration 1 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     pcie_dram_dma_enable           1       0 RW   0x0         Enables the DMA engine path for PCIe to/from DRAM
//     pcie_sram_dma_enable           1       1 RW   0x0         Enables the DMA engine path for PCIe to/from SRAM
//
#define DP_CTL1                                                      0x0000000000048028ULL
#define DP_CTL1_pcie_dram_dma_enable                                 0x0100000000048028ULL
#define DP_CTL1_pcie_sram_dma_enable                                 0x0101000000048028ULL

//
// Register:    DP_RECORDING_SIZE_P0
// Description: Recording map size for half-frame Phase 0
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     cell_cnt                       24  23:00 RW   0x400000    Number of recording cells in half frame Phase 0. Should be
//                                                               set equal to number of 1s in Phase 0 RBM and be an integer
//                                                               multiple of 4096.
//
#define DP_RECORDING_SIZE_P0                                         0x0000000000048088ULL
#define DP_RECORDING_SIZE_P0_cell_cnt                                0x1800000000048088ULL

//
// Register:    DP_RECORDING_SIZE_P1
// Description: Recording map size for half-frame Phase 1
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     cell_cnt                       24  23:00 RW   0x400000    Number of recording cells in half frame Phase 1. Should be
//                                                               set equal to number of 1s in Phase 1 RBM and be an integer
//                                                               multiple of 4096.
//
#define DP_RECORDING_SIZE_P1                                         0x000000000004808cULL
#define DP_RECORDING_SIZE_P1_cell_cnt                                0x180000000004808cULL

//
// Register:    DP_RECORDING_SIZE_P0Q0
// Description: Recording map size for quarter-frame 0 phase 0
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     cell_cnt                       24  23:00 RW   0x400000    Number of recording cells in quarter-frame 0 Phase 0.
//
#define DP_RECORDING_SIZE_P0Q0                                       0x0000000000048090ULL
#define DP_RECORDING_SIZE_P0Q0_cell_cnt                              0x1800000000048090ULL

//
// Register:    DP_RECORDING_SIZE_P0Q1
// Description: Recording map size for quarter-frame 1 phase 0
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     cell_cnt                       24  23:00 RW   0x400000    Number of recording cells in quarter-frame 1 Phase 0.
//
#define DP_RECORDING_SIZE_P0Q1                                       0x0000000000048094ULL
#define DP_RECORDING_SIZE_P0Q1_cell_cnt                              0x1800000000048094ULL

//
// Register:    DP_RECORDING_SIZE_P1Q0
// Description: Recording map size for quarter-frame 0 phase 1
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     cell_cnt                       24  23:00 RW   0x400000    Number of recording cells in quarter-frame 0 Phase 1.
//
#define DP_RECORDING_SIZE_P1Q0                                       0x0000000000048098ULL
#define DP_RECORDING_SIZE_P1Q0_cell_cnt                              0x1800000000048098ULL

//
// Register:    DP_RECORDING_SIZE_P1Q1
// Description: Recording map size for quarter-frame 1 phase 1
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     cell_cnt                       24  23:00 RW   0x400000    Number of recording cells in quarter-frame 1 Phase 1.
//
#define DP_RECORDING_SIZE_P1Q1                                       0x000000000004809cULL
#define DP_RECORDING_SIZE_P1Q1_cell_cnt                              0x180000000004809cULL

//
// Register:    DP_DMA_DESC_CTL
// Description: DP DMA descriptor control Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     chan                           8   07:00 RW   0x0         DMA channel
//     valid                          1       8 RW   0x0         The DMA channel has a valid descriptor. Some DMA agents
//                                                               inside the FPGA will skip the requested DMA when valid=0
//     dma_error                      1      29 RW1C 0x0         Reads 1 if a DMA error has occurred since the bit was last
//                                                               cleared. Write 1 to clear
//     write_in_progress              1      30 RO   0x0         Reads 1 while a configuration write is in progress, 0 when
//                                                               it is safe to initiate a descriptor write
//     dma_write                      1      31 RW   0x0         Write the descriptor when this bit is changed from zero to
//                                                               one. Software must clear this bit before doing another
//                                                               descriptor write. Do not attempt to initiate a new write
//                                                               while write_in_progress still reads 1
//
#define DP_DMA_DESC_CTL                                              0x0000000000048180ULL
#define DP_DMA_DESC_CTL_chan                                         0x0800000000048180ULL
#define DP_DMA_DESC_CTL_valid                                        0x0108000000048180ULL
#define DP_DMA_DESC_CTL_dma_error                                    0x011d000000048180ULL
#define DP_DMA_DESC_CTL_write_in_progress                            0x011e000000048180ULL
#define DP_DMA_DESC_CTL_dma_write                                    0x011f000000048180ULL

//
// Register:    DP_DMA_DESC_WR_ADDR_L
// Description: DP DMA descriptor write address low Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RW   0x0         DMA base address 31:0
//
#define DP_DMA_DESC_WR_ADDR_L                                        0x0000000000048184ULL
#define DP_DMA_DESC_WR_ADDR_L_data                                   0x2000000000048184ULL

//
// Register:    DP_DMA_DESC_WR_ADDR_H
// Description: DP DMA descriptor write address high
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RW   0x0         DMA base address 63:32
//
#define DP_DMA_DESC_WR_ADDR_H                                        0x0000000000048188ULL
#define DP_DMA_DESC_WR_ADDR_H_data                                   0x2000000000048188ULL

//
// Register:    DP_DMA_DESC_WR_SIZE_L
// Description: DP DMA descriptor write size low Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RW   0x0         DMA buffer size (in bytes) 31:0
//
#define DP_DMA_DESC_WR_SIZE_L                                        0x000000000004818cULL
#define DP_DMA_DESC_WR_SIZE_L_data                                   0x200000000004818cULL

//
// Register:    DP_DMA_DESC_WR_SIZE_H
// Description: DP DMA descriptor write size high Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RW   0x0         DMA buffer size (in bytes) 63:32
//
#define DP_DMA_DESC_WR_SIZE_H                                        0x0000000000048190ULL
#define DP_DMA_DESC_WR_SIZE_H_data                                   0x2000000000048190ULL

//
// Register:    DP_DMA_DESC_RD_ADDR_L
// Description: DP DMA descriptor read address low Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RO   0x0         DMA base address 31:0
//
#define DP_DMA_DESC_RD_ADDR_L                                        0x0000000000048194ULL
#define DP_DMA_DESC_RD_ADDR_L_data                                   0x2000000000048194ULL

//
// Register:    DP_DMA_DESC_RD_ADDR_H
// Description: DP DMA descriptor read address high Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RO   0x0         DMA base address 63:32
//
#define DP_DMA_DESC_RD_ADDR_H                                        0x0000000000048198ULL
#define DP_DMA_DESC_RD_ADDR_H_data                                   0x2000000000048198ULL

//
// Register:    DP_DMA_DESC_RD_SIZE_L
// Description: DP DMA descriptor read size low Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RO   0x0         DMA buffer size (in bytes) 31:0
//
#define DP_DMA_DESC_RD_SIZE_L                                        0x000000000004819cULL
#define DP_DMA_DESC_RD_SIZE_L_data                                   0x200000000004819cULL

//
// Register:    DP_DMA_DESC_RD_SIZE_H
// Description: DP DMA descriptor read size low
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RO   0x0         DMA buffer size (in bytes) 63:32
//
#define DP_DMA_DESC_RD_SIZE_H                                        0x00000000000481a0ULL
#define DP_DMA_DESC_RD_SIZE_H_data                                   0x20000000000481a0ULL

//
// Register:    DP_DMA_DESC_RD_OFFSET_L
// Description: DP DMA descriptor read offset low Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RO   0x0         DMA current offset into the buffer 31:0
//
#define DP_DMA_DESC_RD_OFFSET_L                                      0x00000000000481a4ULL
#define DP_DMA_DESC_RD_OFFSET_L_data                                 0x20000000000481a4ULL

//
// Register:    DP_DMA_DESC_RD_OFFSET_H
// Description: DP DMA descriptor read offset high Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RO   0x0         DMA current offset into the buffer 63:32
//
#define DP_DMA_DESC_RD_OFFSET_H                                      0x00000000000481a8ULL
#define DP_DMA_DESC_RD_OFFSET_H_data                                 0x20000000000481a8ULL

//
// Register:    DP_DMA_HOST_STATUS1
// Description: DP Host initiated DMA status Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     bytes_remaining                24  23:00 RO   0x0         Number of bytes remaining in the active transfer
//     dma_not_enabled_err            1      24 RO   0x0         Error: Attempted to start HDMA while both
//                                                               DP_CTL1_pcie_dram_dma_enable==0 and
//                                                               DP_CTL1_pcie_sram_dma_enable==0 Need to enable the dma
//                                                               engine before starting the HDMA. Clears when the start bit
//                                                               is cleared
//     dram_not_ready_err             1      25 RO   0x0         Error: Attempted to start HDMA while DRAM not ready. Clears
//                                                               when the start bit is cleared
//     size_err                       1      26 RO   0x0         Error: Attempted to start HDMA with incorrect DMA size. Size
//                                                               must be >0 and a multiple of 128 bytes. Clears when the
//                                                               start bit is cleared
//     dma_conflict_err               1      27 RO   0x0         Error: Attempted to enable both the engines at the same
//                                                               time. Either DP_CTL1_pcie_dram_dma_enable or
//                                                               DP_CTL1_pcie_sram_dma_enable can be set at a time. Clears
//                                                               when the start bit is cleared
//
#define DP_DMA_HOST_STATUS1                                          0x00000000000481acULL
#define DP_DMA_HOST_STATUS1_bytes_remaining                          0x18000000000481acULL
#define DP_DMA_HOST_STATUS1_dma_not_enabled_err                      0x01180000000481acULL
#define DP_DMA_HOST_STATUS1_dram_not_ready_err                       0x01190000000481acULL
#define DP_DMA_HOST_STATUS1_size_err                                 0x011a0000000481acULL
#define DP_DMA_HOST_STATUS1_dma_conflict_err                         0x011b0000000481acULL

//
// Register:    DP_DMA_HOST_CTL1
// Description: DP Host initiated DMA control Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     dma_size                       24  23:00 RW   0x0         Number of bytes to DMA. Must be a multiple of 128
//     dma_err                        1      28 RO   0x0         An error occurred. See DP_DMA_HOST_STATUS1 to determine
//                                                               cause. Clears when the start bit is cleared
//     dir_h2f                        1      29 RW   0x0         Direction control. 1=Host to FPGA DRAM/SRAM, 0=FPGA
//                                                               DRAM/SRAM to Host
//     done                           1      30 RO   0x0         When one, the DMA is complete. Clears when the start bit is
//                                                               cleared
//     start                          1      31 RW   0x0         Start the DMA when this bit is changed from zero to one.
//                                                               Software must clear this bit before starting another DMA
//
#define DP_DMA_HOST_CTL1                                             0x00000000000481b0ULL
#define DP_DMA_HOST_CTL1_dma_size                                    0x18000000000481b0ULL
#define DP_DMA_HOST_CTL1_dma_err                                     0x011c0000000481b0ULL
#define DP_DMA_HOST_CTL1_dir_h2f                                     0x011d0000000481b0ULL
#define DP_DMA_HOST_CTL1_done                                        0x011e0000000481b0ULL
#define DP_DMA_HOST_CTL1_start                                       0x011f0000000481b0ULL

//
// Register:    DP_FG_CNT0_RD
// Description: DP Frame Counter (Phase 0) Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     cnt                            32  31:00 RO   0x0         FGP Frame Counter for phase 0
//
#define DP_FG_CNT0_RD                                                0x00000000000481b4ULL
#define DP_FG_CNT0_RD_cnt                                            0x20000000000481b4ULL

//
// Register:    DP_FG_CNT1_RD
// Description: DP Frame Counter (Phase 1) Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     cnt                            32  31:00 RO   0x0         FGP Frame Counter for phase 1
//
#define DP_FG_CNT1_RD                                                0x00000000000481b8ULL
#define DP_FG_CNT1_RD_cnt                                            0x20000000000481b8ULL

//
// Register:    DP_FG_CNT_WR
// Description: DP Frame Counter Control Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     clr                            1       0 RW   0x0         Clear the phase 0 and phase 1 FGP frame counters
//                                                               (DP_FG_CNT0_RD, DP_FG_CNT1_RD)
//
#define DP_FG_CNT_WR                                                 0x00000000000481bcULL
#define DP_FG_CNT_WR_clr                                             0x01000000000481bcULL

//
// Register:    DP_HEADER_STATUS
// Description: DP Header Status Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     axirderr                       1       0 RW1C 0x0         1 if error has occurred since last clear. Write 1 to clear.
//     axirresp                       2   02:01 RO   0x0         When DP_HEADER_STATUS_axirderr transitions from 0 to 1, this
//                                                               field captures the associated RRESP (read response) code.
//     axiwrerr                       1       3 RW1C 0x0         1 if error has occurred since last clear. Write 1 to clear.
//     axibresp                       2   05:04 RO   0x0         When DP_HEADER_STATUS_axiwrerr transitions from 0 to 1, this
//                                                               field captures the associated BRESP (write response) code.
//
#define DP_HEADER_STATUS                                             0x0000000000048700ULL
#define DP_HEADER_STATUS_axirderr                                    0x0100000000048700ULL
#define DP_HEADER_STATUS_axirresp                                    0x0201000000048700ULL
#define DP_HEADER_STATUS_axiwrerr                                    0x0103000000048700ULL
#define DP_HEADER_STATUS_axibresp                                    0x0204000000048700ULL

//
// Register:    DP_FIFO_STATUS2
// Description: DP FIFO health status register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     hdma_dfifo_overflow            1      26 RW1C 0x0         1 if error has occurred since last clear. Write 1 to clear
//     hdma_dfifo_underflow           1      27 RW1C 0x0         1 if error has occurred since last clear. Write 1 to clear
//     hdma_raddr_fifo_overflow       1      28 RW1C 0x0         1 if error has occurred since last clear. Write 1 to clear
//     hdma_waddr_fifo_overflow       1      29 RW1C 0x0         1 if error has occurred since last clear. Write 1 to clear
//
#define DP_FIFO_STATUS2                                              0x0000000000048704ULL
#define DP_FIFO_STATUS2_hdma_dfifo_overflow                          0x011a000000048704ULL
#define DP_FIFO_STATUS2_hdma_dfifo_underflow                         0x011b000000048704ULL
#define DP_FIFO_STATUS2_hdma_raddr_fifo_overflow                     0x011c000000048704ULL
#define DP_FIFO_STATUS2_hdma_waddr_fifo_overflow                     0x011d000000048704ULL

//
// Register:    DP_FIFO_STATUS3
// Description: DP FIFO health status register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     hs2mem_axirderr                1       0 RW1C 0x0         1 if error has occurred since last clear. Write 1 to clear
//     hs2mem_axirresp                2   02:01 RO   0x0         When DP_FIFO_STATUS3_hs2mem_axirderr transitions from 0 to
//                                                               1, this field captures the associated RRESP (read response)
//                                                               code.
//     hs2mem_axiwrerr                1       3 RW1C 0x0         1 if error has occurred since last clear. Write 1 to clear
//     hs2mem_axibresp                2   05:04 RO   0x0         When DP_FIFO_STATUS3_hs2mem_axiwrerr transitions from 0 to
//                                                               1, this field captures the associated BRESP (write response)
//                                                               code.
//     hs2pcie_axirderr               1       6 RW1C 0x0         1 if error has occurred since last clear. Write 1 to clear
//     hs2pcie_axirresp               2   08:07 RO   0x0         When DP_FIFO_STATUS3_hs2pcie_axirderr transitions from 0 to
//                                                               1, this field captures the associated RRESP (read response)
//                                                               code.
//     dp_dma_addr_gen_req_fifo_overflow 1      15 RW1C 0x0         1 if error has occurred since last clear. Write 1 to clear
//     dp_dma_addr_gen_rsp_fifo_overflow 1      16 RW1C 0x0         1 if error has occurred since last clear. Write 1 to clear
//     dp_dma_addr_gen_rsp_fifo_underflow 1      17 RW1C 0x0         1 if error has occurred since last clear. Write 1 to clear
//
#define DP_FIFO_STATUS3                                              0x0000000000048708ULL
#define DP_FIFO_STATUS3_hs2mem_axirderr                              0x0100000000048708ULL
#define DP_FIFO_STATUS3_hs2mem_axirresp                              0x0201000000048708ULL
#define DP_FIFO_STATUS3_hs2mem_axiwrerr                              0x0103000000048708ULL
#define DP_FIFO_STATUS3_hs2mem_axibresp                              0x0204000000048708ULL
#define DP_FIFO_STATUS3_hs2pcie_axirderr                             0x0106000000048708ULL
#define DP_FIFO_STATUS3_hs2pcie_axirresp                             0x0207000000048708ULL
#define DP_FIFO_STATUS3_dp_dma_addr_gen_req_fifo_overflow            0x010f000000048708ULL
#define DP_FIFO_STATUS3_dp_dma_addr_gen_rsp_fifo_overflow            0x0110000000048708ULL
#define DP_FIFO_STATUS3_dp_dma_addr_gen_rsp_fifo_underflow           0x0111000000048708ULL

//
// Register:    DP_HEADER_STATUS2
// Description: DP Header Status2 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     p0_hdr_wr                      32  31:00 RO   0x0         Max observed number of p0 hdr wr
//
#define DP_HEADER_STATUS2                                            0x000000000004870cULL
#define DP_HEADER_STATUS2_p0_hdr_wr                                  0x200000000004870cULL

//
// Register:    DP_HEADER_STATUS3
// Description: DP Header Status3 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     p1_hdr_wr                      32  31:00 RO   0x0         Max observed number of p1 hdr wr
//
#define DP_HEADER_STATUS3                                            0x0000000000048710ULL
#define DP_HEADER_STATUS3_p1_hdr_wr                                  0x2000000000048710ULL

//
// Register:    DP_HEADER_STATUS4
// Description: DP Header Status4 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     p1_hdr_ctr                     16  15:00 RO   0x0         p1 hdr ctr
//     p0_hdr_ctr                     16  31:16 RO   0x0         p0 hdr ctr
//
#define DP_HEADER_STATUS4                                            0x0000000000048714ULL
#define DP_HEADER_STATUS4_p1_hdr_ctr                                 0x1000000000048714ULL
#define DP_HEADER_STATUS4_p0_hdr_ctr                                 0x1010000000048714ULL

//
// Register:    DP_HEADER_STATUS5
// Description: DP Header Status5 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     p1_batch_cpl_ctr               16  15:00 RO   0x0         p1 batch cpl ctr
//     p0_batch_cpl_ctr               16  31:16 RO   0x0         p0 batch cpl ctr
//
#define DP_HEADER_STATUS5                                            0x0000000000048718ULL
#define DP_HEADER_STATUS5_p1_batch_cpl_ctr                           0x1000000000048718ULL
#define DP_HEADER_STATUS5_p0_batch_cpl_ctr                           0x1010000000048718ULL

//
// Register:    DP_HFRAME_BUFFER_START_ADDR_HI_P0
// Description: DP half frame phase 0 start address high
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RW   0x0         DP half frame phase 0 start address high 63:32
//
#define DP_HFRAME_BUFFER_START_ADDR_HI_P0                            0x0000000000048800ULL
#define DP_HFRAME_BUFFER_START_ADDR_HI_P0_data                       0x2000000000048800ULL

//
// Register:    DP_HFRAME_BUFFER_START_ADDR_LO_P0
// Description: DP half frame phase 0 start address low
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RW   0x0         DP half frame phase 0 start address low 31:0
//
#define DP_HFRAME_BUFFER_START_ADDR_LO_P0                            0x0000000000048804ULL
#define DP_HFRAME_BUFFER_START_ADDR_LO_P0_data                       0x2000000000048804ULL

//
// Register:    DP_HFRAME_BUFFER_SIZE_P0
// Description: DP half frame phase 0 buffer size
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RW   0x0         DP half frame phase 0 buffer size
//
#define DP_HFRAME_BUFFER_SIZE_P0                                     0x0000000000048808ULL
#define DP_HFRAME_BUFFER_SIZE_P0_data                                0x2000000000048808ULL

//
// Register:    DP_HFRAME_BUFFER_START_ADDR_HI_P1
// Description: DP half frame phase 1 start address high
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RW   0x0         DP half frame phase 1 start address high 63:32
//
#define DP_HFRAME_BUFFER_START_ADDR_HI_P1                            0x000000000004880cULL
#define DP_HFRAME_BUFFER_START_ADDR_HI_P1_data                       0x200000000004880cULL

//
// Register:    DP_HFRAME_BUFFER_START_ADDR_LO_P1
// Description: DP half frame phase 1 start address low
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RW   0x0         DP half frame phase 1 start address low 31:0
//
#define DP_HFRAME_BUFFER_START_ADDR_LO_P1                            0x0000000000048810ULL
#define DP_HFRAME_BUFFER_START_ADDR_LO_P1_data                       0x2000000000048810ULL

//
// Register:    DP_HFRAME_BUFFER_SIZE_P1
// Description: DP half frame phase 1 buffer size
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RW   0x0         DP half frame phase 1 buffer size
//
#define DP_HFRAME_BUFFER_SIZE_P1                                     0x0000000000048814ULL
#define DP_HFRAME_BUFFER_SIZE_P1_data                                0x2000000000048814ULL

//
// Register:    DP_QFRAME_BUFFER_START_ADDR_HI_P0Q0
// Description: DP Phase0 quarter-frame0 Start address high
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RW   0x0         DP Phase0 quarter-frame0 start address high 63:32
//
#define DP_QFRAME_BUFFER_START_ADDR_HI_P0Q0                          0x0000000000048900ULL
#define DP_QFRAME_BUFFER_START_ADDR_HI_P0Q0_data                     0x2000000000048900ULL

//
// Register:    DP_QFRAME_BUFFER_START_ADDR_LO_P0Q0
// Description: DP Phase0 quarter-frame0 start address low
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RW   0x0         DP Phase0 quarter-frame0 start address low 31:0
//
#define DP_QFRAME_BUFFER_START_ADDR_LO_P0Q0                          0x0000000000048904ULL
#define DP_QFRAME_BUFFER_START_ADDR_LO_P0Q0_data                     0x2000000000048904ULL

//
// Register:    DP_QFRAME_BUFFER_SIZE_P0Q0
// Description: DP Phase0 quarter-frame0 buffer size
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RW   0x0         DP Phase0 quarter-frame0 buffer size
//
#define DP_QFRAME_BUFFER_SIZE_P0Q0                                   0x0000000000048908ULL
#define DP_QFRAME_BUFFER_SIZE_P0Q0_data                              0x2000000000048908ULL

//
// Register:    DP_QFRAME_BUFFER_START_ADDR_HI_P0Q1
// Description: DP Phase0 quarter-frame1 Start address high
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RW   0x0         DP Phase0 quarter-frame1 start address high 63:32
//
#define DP_QFRAME_BUFFER_START_ADDR_HI_P0Q1                          0x000000000004890cULL
#define DP_QFRAME_BUFFER_START_ADDR_HI_P0Q1_data                     0x200000000004890cULL

//
// Register:    DP_QFRAME_BUFFER_START_ADDR_LO_P0Q1
// Description: DP Phase0 quarter-frame1 start address low
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RW   0x0         DP Phase0 quarter-frame1 start address low 31:0
//
#define DP_QFRAME_BUFFER_START_ADDR_LO_P0Q1                          0x0000000000048910ULL
#define DP_QFRAME_BUFFER_START_ADDR_LO_P0Q1_data                     0x2000000000048910ULL

//
// Register:    DP_QFRAME_BUFFER_SIZE_P0Q1
// Description: DP Phase0 quarter-frame1 buffer size
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RW   0x0         DP Phase0 quarter-frame1 buffer size
//
#define DP_QFRAME_BUFFER_SIZE_P0Q1                                   0x0000000000048914ULL
#define DP_QFRAME_BUFFER_SIZE_P0Q1_data                              0x2000000000048914ULL

//
// Register:    DP_QFRAME_BUFFER_START_ADDR_HI_P1Q0
// Description: DP Phase1 quarter-frame0 Start address high
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RW   0x0         DP Phase1 quarter-frame0 start address high 63:32
//
#define DP_QFRAME_BUFFER_START_ADDR_HI_P1Q0                          0x0000000000048918ULL
#define DP_QFRAME_BUFFER_START_ADDR_HI_P1Q0_data                     0x2000000000048918ULL

//
// Register:    DP_QFRAME_BUFFER_START_ADDR_LO_P1Q0
// Description: DP Phase1 quarter-frame0 start address low
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RW   0x0         DP Phase1 quarter-frame0 start address low 31:0
//
#define DP_QFRAME_BUFFER_START_ADDR_LO_P1Q0                          0x000000000004891cULL
#define DP_QFRAME_BUFFER_START_ADDR_LO_P1Q0_data                     0x200000000004891cULL

//
// Register:    DP_QFRAME_BUFFER_SIZE_P1Q0
// Description: DP Phase1 quarter-frame0 buffer size
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RW   0x0         DP Phase1 quarter-frame0 buffer size
//
#define DP_QFRAME_BUFFER_SIZE_P1Q0                                   0x0000000000048920ULL
#define DP_QFRAME_BUFFER_SIZE_P1Q0_data                              0x2000000000048920ULL

//
// Register:    DP_QFRAME_BUFFER_START_ADDR_HI_P1Q1
// Description: DP Phase1 quarter-frame1 Start address high
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RW   0x0         DP Phase1 quarter-frame1 start address high 63:32
//
#define DP_QFRAME_BUFFER_START_ADDR_HI_P1Q1                          0x0000000000048924ULL
#define DP_QFRAME_BUFFER_START_ADDR_HI_P1Q1_data                     0x2000000000048924ULL

//
// Register:    DP_QFRAME_BUFFER_START_ADDR_LO_P1Q1
// Description: DP Phase1 quarter-frame1 start address low
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RW   0x0         DP Phase1 quarter-frame1 start address low 31:0
//
#define DP_QFRAME_BUFFER_START_ADDR_LO_P1Q1                          0x0000000000048928ULL
#define DP_QFRAME_BUFFER_START_ADDR_LO_P1Q1_data                     0x2000000000048928ULL

//
// Register:    DP_QFRAME_BUFFER_SIZE_P1Q1
// Description: DP Phase0 quarter-frame0 buffer size
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RW   0x0         DP Phase1 quarter-frame1 buffer size
//
#define DP_QFRAME_BUFFER_SIZE_P1Q1                                   0x000000000004892cULL
#define DP_QFRAME_BUFFER_SIZE_P1Q1_data                              0x200000000004892cULL

//
// Register:    DP_COMPR_STATUS1
// Description: DP Compression Status1 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     req_fifo_ovf                   1       0 RW1C 0x0         Reads 1 if Request FIFO Overflow has occurred since the bit
//                                                               was last cleared. Write 1 to clear
//     data_fifo_ovf                  1       1 RW1C 0x0         Reads 1 if Data FIFO Overflow has occurred since the bit was
//                                                               last cleared. Write 1 to clear
//     resp_fifo_ovf                  1       2 RW1C 0x0         Reads 1 if Resp FIFO Overflow has occurred since the bit was
//                                                               last cleared. Write 1 to clear
//     resp_fifo_uf                   1       3 RW1C 0x0         Reads 1 if Resp FIFO Underflow has occurred since the bit
//                                                               was last cleared. Write 1 to clear
//     axiwrerr                       1       4 RW1C 0x0         Reads 1 if error has occurred since the bit was last
//                                                               cleared. Write 1 to clear
//     axibresp                       2   06:05 RO   0x0         When DP_COMPR_STATUS1_axiwrerr transitions from 0 to 1, this
//                                                               field captures the associated BRESP (write response) code.
//     data_dropped                   1       7 RW1C 0x0         Reads 1 if AXI write buffer dropped 1 or more AXI burst
//                                                               writes for any reason (FIFO too full or software drop
//                                                               request). Write 1 to clear
//     fifo_too_full                  1       8 RW1C 0x0         Reads 1 if FIFO too full threshold tripped in the AXI write
//                                                               buffer. Write 1 to clear.
//     drop_req_processed             1       9 RW1C 0x0         Reads 1 if a software drop request has been processed since
//                                                               last clear. Write 1 to clear.
//     queued_drops                   8   17:10 RO   0x0         Reports how many data drops are currently queued due to
//                                                               toggling DP_COMPR_STATUS1_CTL_drop_req from 0 to 1.
//
#define DP_COMPR_STATUS1                                             0x0000000000048a00ULL
#define DP_COMPR_STATUS1_req_fifo_ovf                                0x0100000000048a00ULL
#define DP_COMPR_STATUS1_data_fifo_ovf                               0x0101000000048a00ULL
#define DP_COMPR_STATUS1_resp_fifo_ovf                               0x0102000000048a00ULL
#define DP_COMPR_STATUS1_resp_fifo_uf                                0x0103000000048a00ULL
#define DP_COMPR_STATUS1_axiwrerr                                    0x0104000000048a00ULL
#define DP_COMPR_STATUS1_axibresp                                    0x0205000000048a00ULL
#define DP_COMPR_STATUS1_data_dropped                                0x0107000000048a00ULL
#define DP_COMPR_STATUS1_fifo_too_full                               0x0108000000048a00ULL
#define DP_COMPR_STATUS1_drop_req_processed                          0x0109000000048a00ULL
#define DP_COMPR_STATUS1_queued_drops                                0x080a000000048a00ULL

//
// Register:    DP_COMPR_STATUS2
// Description: DP Compression Status2 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     req_fifo_depth                 16  15:00 RO   0x0         Number of queued request entries from packer
//     data_fifo_depth                16  31:16 RO   0x0         Number of queued data entries from packer
//
#define DP_COMPR_STATUS2                                             0x0000000000048a04ULL
#define DP_COMPR_STATUS2_req_fifo_depth                              0x1000000000048a04ULL
#define DP_COMPR_STATUS2_data_fifo_depth                             0x1010000000048a04ULL

//
// Register:    DP_COMPR_STATUS3
// Description: DP Compression Status3 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     max_obs_req_fifo_depth         16  15:00 RO   0x0         Max observed number of queued request entries from packer
//     max_obs_data_fifo_depth        16  31:16 RO   0x0         Maximum observed number of queued data entries from packer
//
#define DP_COMPR_STATUS3                                             0x0000000000048a08ULL
#define DP_COMPR_STATUS3_max_obs_req_fifo_depth                      0x1000000000048a08ULL
#define DP_COMPR_STATUS3_max_obs_data_fifo_depth                     0x1010000000048a08ULL

//
// Register:    DP_COMPR_STATUS4
// Description: DP Compression Status4 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     max_obs_resp_fifo_depth        16  15:00 RO   0x0         Max observed number of queued response entries
//     resp_fifo_depth                16  31:16 RO   0x0         Number of queued response entries
//
#define DP_COMPR_STATUS4                                             0x0000000000048a0cULL
#define DP_COMPR_STATUS4_max_obs_resp_fifo_depth                     0x1000000000048a0cULL
#define DP_COMPR_STATUS4_resp_fifo_depth                             0x1010000000048a0cULL

//
// Register:    DP_COMPR_STATUS3_CTL
// Description: DP Compression Status3 Control Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     clear_max_obs_req_fifo_depth   1       0 RW   0x0         The rising edge (0 to 1 transition) of this bit clears Max
//                                                               Obs Req Fifo Depth
//     clear_max_obs_data_fifo_depth  1       1 RW   0x0         The rising edge (0 to 1 transition) of this bit clears Max
//                                                               Obs Data Fifo Depth
//     clear_max_obs_resp_fifo_depth  1       2 RW   0x0         The rising edge (0 to 1 transition) of this bit clears Max
//                                                               Obs Resp Fifo Depth
//     dbg_reset                      1       3 RW   0x0         The rising edge (0 to 1 transition) of this bit resets compr
//                                                               debug registers
//
#define DP_COMPR_STATUS3_CTL                                         0x0000000000048a10ULL
#define DP_COMPR_STATUS3_CTL_clear_max_obs_req_fifo_depth            0x0100000000048a10ULL
#define DP_COMPR_STATUS3_CTL_clear_max_obs_data_fifo_depth           0x0101000000048a10ULL
#define DP_COMPR_STATUS3_CTL_clear_max_obs_resp_fifo_depth           0x0102000000048a10ULL
#define DP_COMPR_STATUS3_CTL_dbg_reset                               0x0103000000048a10ULL

//
// Register:    DP_COMPR_STATUS1_CTL
// Description: DP Compression Status1 Control Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     drop_req                       1       0 RW   0x0         The rising edge of this bit (transition from 0 to 1) queues
//                                                               a data drop event for testing purposes. Each rising edge
//                                                               will cause one AXI write to be dropped, up to a maximum of
//                                                               255. Drops occur at the earliest possible opportunity.
//     wb_dbg_reset                   1       1 RW   0x0         The rising edge (0 to 1 transition) of this bit resets write
//                                                               buffer debug registers
//
#define DP_COMPR_STATUS1_CTL                                         0x0000000000048a14ULL
#define DP_COMPR_STATUS1_CTL_drop_req                                0x0100000000048a14ULL
#define DP_COMPR_STATUS1_CTL_wb_dbg_reset                            0x0101000000048a14ULL

//
// Register:    DP_COMPR_STATUS5
// Description: DP Compression Status5 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     max_obs_wfifo_depth            16  15:00 RO   0x0         Max observed number of queued wfifo entries
//     max_obs_keep_fifo_depth        16  31:16 RO   0x0         Max observed number of queued keep entries
//
#define DP_COMPR_STATUS5                                             0x0000000000048a18ULL
#define DP_COMPR_STATUS5_max_obs_wfifo_depth                         0x1000000000048a18ULL
#define DP_COMPR_STATUS5_max_obs_keep_fifo_depth                     0x1010000000048a18ULL

//
// Register:    DP_COMPR_STATUS6
// Description: DP Compression Status6 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     max_obs_ingr_fifo_depth        16  15:00 RO   0x0         Max observed number of queued ingress entries
//     max_obs_egr_fifo_depth         16  31:16 RO   0x0         Max observed number of queued egress entries
//
#define DP_COMPR_STATUS6                                             0x0000000000048a1cULL
#define DP_COMPR_STATUS6_max_obs_ingr_fifo_depth                     0x1000000000048a1cULL
#define DP_COMPR_STATUS6_max_obs_egr_fifo_depth                      0x1010000000048a1cULL

//
// Register:    DP_COMPR_STATUS7
// Description: DP Compression Status7 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     max_obs_bfifo_depth            16  15:00 RO   0x0         Max observed number of queued bfifo entries
//     max_obs_wb_bresp               16  31:16 RO   0x0         Maximum observed number of wb bresp pending
//
#define DP_COMPR_STATUS7                                             0x0000000000048a20ULL
#define DP_COMPR_STATUS7_max_obs_bfifo_depth                         0x1000000000048a20ULL
#define DP_COMPR_STATUS7_max_obs_wb_bresp                            0x1010000000048a20ULL

//
// Register:    DP_COMPR_STATUS8
// Description: DP Compression Status8 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     max_obs_p0_cpl                 32  31:00 RO   0x0         Max observed number of P0 frame cpl
//
#define DP_COMPR_STATUS8                                             0x0000000000048a24ULL
#define DP_COMPR_STATUS8_max_obs_p0_cpl                              0x2000000000048a24ULL

//
// Register:    DP_COMPR_STATUS9
// Description: DP Compression Status9 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     max_obs_p1_cpl                 32  31:00 RO   0x0         Max observed number of P1 frame cpl
//
#define DP_COMPR_STATUS9                                             0x0000000000048a28ULL
#define DP_COMPR_STATUS9_max_obs_p1_cpl                              0x2000000000048a28ULL

//
// Register:    DP_COMPR_STATUS10
// Description: DP Compression Status10 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     max_obs_even_resp              16  15:00 RO   0x0         Max observed number of even Resp
//     max_obs_odd_resp               16  31:16 RO   0x0         Max observed number of odd Resp
//
#define DP_COMPR_STATUS10                                            0x0000000000048a2cULL
#define DP_COMPR_STATUS10_max_obs_even_resp                          0x1000000000048a2cULL
#define DP_COMPR_STATUS10_max_obs_odd_resp                           0x1010000000048a2cULL

//
// Register:    DP_COMPR_STATUS11
// Description: DP Compression Status11 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     compr2pcie_aw_stall            1       0 RO   0x0         COMPR2PCIE stall: awvalid without awready
//     compr2pcie_w_stall             1       1 RO   0x0         COMPR2PCIE stall: wvalid without wready
//     dp2pcie_aw_stall               1       2 RO   0x0         DP2PCIE stall: awvalid without awready
//     dp2pcie_w_stall                1       3 RO   0x0         DP2PCIE stall: wvalid without wready, during backpressure
//     wb_dropped                     1       4 RW1C 0x0         DP WB: dropped. Write 1 to clear
//     wb_full                        1       5 RW1C 0x0         DP WB: full. Write 1 to clear
//
#define DP_COMPR_STATUS11                                            0x0000000000048a30ULL
#define DP_COMPR_STATUS11_compr2pcie_aw_stall                        0x0100000000048a30ULL
#define DP_COMPR_STATUS11_compr2pcie_w_stall                         0x0101000000048a30ULL
#define DP_COMPR_STATUS11_dp2pcie_aw_stall                           0x0102000000048a30ULL
#define DP_COMPR_STATUS11_dp2pcie_w_stall                            0x0103000000048a30ULL
#define DP_COMPR_STATUS11_wb_dropped                                 0x0104000000048a30ULL
#define DP_COMPR_STATUS11_wb_full                                    0x0105000000048a30ULL

//
// Register:    DP_COMPR_STATUS12
// Description: DP Compr Status12 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     p0_compr_phase                 32  31:00 RO   0x0         Max observed number of p0 compr phase
//
#define DP_COMPR_STATUS12                                            0x0000000000048a34ULL
#define DP_COMPR_STATUS12_p0_compr_phase                             0x2000000000048a34ULL

//
// Register:    DP_COMPR_STATUS13
// Description: DP Compr Status13 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     p1_compr_phase                 32  31:00 RO   0x0         Max observed number of p1 compr phase
//
#define DP_COMPR_STATUS13                                            0x0000000000048a38ULL
#define DP_COMPR_STATUS13_p1_compr_phase                             0x2000000000048a38ULL

//
// Register:    DP_COMPR_STATUS14
// Description: DP Compr Status14 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     p0_rfifo_phase                 32  31:00 RO   0x0         Max observed number of p0 rfifo phase
//
#define DP_COMPR_STATUS14                                            0x0000000000048a3cULL
#define DP_COMPR_STATUS14_p0_rfifo_phase                             0x2000000000048a3cULL

//
// Register:    DP_COMPR_STATUS15
// Description: DP Compr Status15 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     p1_rfifo_phase                 32  31:00 RO   0x0         Max observed number of p1 rfifo phase
//
#define DP_COMPR_STATUS15                                            0x0000000000048a40ULL
#define DP_COMPR_STATUS15_p1_rfifo_phase                             0x2000000000048a40ULL

//
// Register:    DP_HEADER_STATUS16
// Description: DP Header Status16 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     max_obs_drop_fifo_depth        12  11:00 RO   0x0         Max observed number of queued drop fifo entries
//     drop_fifo_depth                12  23:12 RO   0x0         Number of queued drop fifo entries
//     hdr_drop_fifo_ovf              1      24 RW1C 0x0         Reads 1 if Header Drop FIFO Overflow has occurred since the
//                                                               bit was last cleared. Write 1 to clear
//
#define DP_HEADER_STATUS16                                           0x0000000000048a4cULL
#define DP_HEADER_STATUS16_max_obs_drop_fifo_depth                   0x0c00000000048a4cULL
#define DP_HEADER_STATUS16_drop_fifo_depth                           0x0c0c000000048a4cULL
#define DP_HEADER_STATUS16_hdr_drop_fifo_ovf                         0x0118000000048a4cULL

//
// Register:    DP_HEADER_CTL1
// Description: DP Header Control1 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     drop_fifo_reset                1       0 RW   0x0         The rising edge (0 to 1 transition) of this bit resets drop
//                                                               fifo contents
//
#define DP_HEADER_CTL1                                               0x0000000000048a50ULL
#define DP_HEADER_CTL1_drop_fifo_reset                               0x0100000000048a50ULL

//
// Register:    DP_ALOG_CFG
// Description: DP DMA Address Log Configuration Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     chan                           8   07:00 RW   0x0         Selects which DMA channel to monitor
//     port                           3   10:08 RW   0x0         Selects which DMA address generator port to monitor. 0=host
//                                                               DMA, 1=header
//     flush                          1      11 RW   0x0         Set to 1 to flush the address log FIFO
//
#define DP_ALOG_CFG                                                  0x0000000000049000ULL
#define DP_ALOG_CFG_chan                                             0x0800000000049000ULL
#define DP_ALOG_CFG_port                                             0x0308000000049000ULL
#define DP_ALOG_CFG_flush                                            0x010b000000049000ULL

//
// Register:    DP_ALOG_DATA
// Description: DP DMA Address Log Data
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     dat                            32  31:00 RO   0x0         Read this register to read and pop an entry from the address
//                                                               log FIFO. Bit 31: valid (if 0, FIFO was empty at time of
//                                                               read). Bit 30: Reads 1 if FIFO overflowed since the previous
//                                                               read. Bits 29:0: bits 41:12 of a logged address if bit 31 is
//                                                               1, otherwise meaningless
//
#define DP_ALOG_DATA                                                 0x0000000000049004ULL
#define DP_ALOG_DATA_dat                                             0x2000000000049004ULL

//
// Register:    DP_PCIE_LTSSM_STATUS
// Description: High Speed interface configuration
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     ltssm_state                    6   05:00 RO   0x0         Captures the current LTSSM (Link Training and Status State
//                                                               Machine) state output by the the Xilinx PCIe core. LTSSM
//                                                               state can be used to diagnose PCIe problems. A map of
//                                                               numeric values to LTSSM state names can be found in Table
//                                                               2-14 of Xilinx document PG023 (port cfg_ltssm_state).
//     clear_ltssm_history            1      31 RW   0x0         The rising edge (0 to 1 transition) of this bit clears the
//                                                               history information in DP_PCIE_LTSSM_HISTORY_L/H.
//
#define DP_PCIE_LTSSM_STATUS                                         0x0000000000049100ULL
#define DP_PCIE_LTSSM_STATUS_ltssm_state                             0x0600000000049100ULL
#define DP_PCIE_LTSSM_STATUS_clear_ltssm_history                     0x011f000000049100ULL

//
// Register:    DP_PCIE_LTSSM_HISTORY_L
// Description: DP PCIe LTSSM History, states 0-31
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     hist                           32  31:00 RO   0x0         Bits 31:0 of the PCIe LTSSM history vector. Bit N in the
//                                                               vector is set to 1 if DP_PCIE_LTSSM_STATUS_ltssm_state has
//                                                               been equal to N since the last FPGA reset or LTSSM history
//                                                               clear.
//
#define DP_PCIE_LTSSM_HISTORY_L                                      0x0000000000049104ULL
#define DP_PCIE_LTSSM_HISTORY_L_hist                                 0x2000000000049104ULL

//
// Register:    DP_PCIE_LTSSM_HISTORY_H
// Description: DP PCIe LTSSM History, states 32-63
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     hist                           32  31:00 RO   0x0         Bits 63:32 of the PCIe LTSSM history vector. Bit N in the
//                                                               vector is set to 1 if DP_PCIE_LTSSM_STATUS_ltssm_state has
//                                                               been equal to N since the last FPGA reset or LTSSM history
//                                                               clear.
//
#define DP_PCIE_LTSSM_HISTORY_H                                      0x0000000000049108ULL
#define DP_PCIE_LTSSM_HISTORY_H_hist                                 0x2000000000049108ULL

//
// Register:    DP_HDMA2DDR_AXIMON1
// Description: AXI Monitor 1 - Queue depth counters and overflow/underflow flags
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     ar_qd                          8   07:00 RO   0x0         Returns the current queue depth of the AR channel.
//     aw_qd                          8   15:08 RO   0x0         Returns the current queue depth of the AW channel.
//     w_qd                           8   23:16 RO   0x0         Returns the current queue depth of the W channel.
//     ar_qd_ovf                      1      24 RW1C 0x0         1 if the counter overflowed. Write 1 to clear.
//     ar_qd_uf                       1      25 RW1C 0x0         1 if the counter underflowed. Write 1 to clear.
//     aw_qd_ovf                      1      26 RW1C 0x0         1 if the counter overflowed. Write 1 to clear.
//     aw_qd_uf                       1      27 RW1C 0x0         1 if the counter underflowed. Write 1 to clear.
//     w_qd_ovf                       1      28 RW1C 0x0         1 if the counter overflowed. Write 1 to clear.
//     w_qd_uf                        1      29 RW1C 0x0         1 if the counter underflowed. Write 1 to clear.
//     reset_ctrs                     1      31 RW   0x0         While 1, queue depth and queue depth highwater counters are
//                                                               reset to 0.
//
#define DP_HDMA2DDR_AXIMON1                                          0x000000000004a000ULL
#define DP_HDMA2DDR_AXIMON1_ar_qd                                    0x080000000004a000ULL
#define DP_HDMA2DDR_AXIMON1_aw_qd                                    0x080800000004a000ULL
#define DP_HDMA2DDR_AXIMON1_w_qd                                     0x081000000004a000ULL
#define DP_HDMA2DDR_AXIMON1_ar_qd_ovf                                0x011800000004a000ULL
#define DP_HDMA2DDR_AXIMON1_ar_qd_uf                                 0x011900000004a000ULL
#define DP_HDMA2DDR_AXIMON1_aw_qd_ovf                                0x011a00000004a000ULL
#define DP_HDMA2DDR_AXIMON1_aw_qd_uf                                 0x011b00000004a000ULL
#define DP_HDMA2DDR_AXIMON1_w_qd_ovf                                 0x011c00000004a000ULL
#define DP_HDMA2DDR_AXIMON1_w_qd_uf                                  0x011d00000004a000ULL
#define DP_HDMA2DDR_AXIMON1_reset_ctrs                               0x011f00000004a000ULL

//
// Register:    DP_HDMA2DDR_AXIMON2
// Description: AXI Monitor 2 - Queue depth counter high water marks, read/write error reporting
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     ar_qd_highwater                8   07:00 RO   0x0         Returns the maximum observed queue depth of the AR channel.
//     aw_qd_highwater                8   15:08 RO   0x0         Returns the maximum observed queue depth of the AW channel.
//     w_qd_highwater                 8   23:16 RO   0x0         Returns the maximum observed queue depth of the W channel.
//     rderr                          1      24 RW1C 0x0         1 if an AXI read error occurred. Write 1 to clear.
//     rresp                          2   26:25 RO   0x0         Records the RRESP code observed during the last read error.
//     wrerr                          1      28 RW1C 0x0         1 if an AXI write error occurred. Write 1 to clear.
//     bresp                          2   30:29 RO   0x0         Records the BRESP code observed during the last write error.
//
#define DP_HDMA2DDR_AXIMON2                                          0x000000000004a004ULL
#define DP_HDMA2DDR_AXIMON2_ar_qd_highwater                          0x080000000004a004ULL
#define DP_HDMA2DDR_AXIMON2_aw_qd_highwater                          0x080800000004a004ULL
#define DP_HDMA2DDR_AXIMON2_w_qd_highwater                           0x081000000004a004ULL
#define DP_HDMA2DDR_AXIMON2_rderr                                    0x011800000004a004ULL
#define DP_HDMA2DDR_AXIMON2_rresp                                    0x021900000004a004ULL
#define DP_HDMA2DDR_AXIMON2_wrerr                                    0x011c00000004a004ULL
#define DP_HDMA2DDR_AXIMON2_bresp                                    0x021d00000004a004ULL

//
// Register:    DP_HDMA2SRAM_AXIMON1
// Description: AXI Monitor 1 - Queue depth counters and overflow/underflow flags
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     ar_qd                          8   07:00 RO   0x0         Returns the current queue depth of the AR channel.
//     aw_qd                          8   15:08 RO   0x0         Returns the current queue depth of the AW channel.
//     w_qd                           8   23:16 RO   0x0         Returns the current queue depth of the W channel.
//     ar_qd_ovf                      1      24 RW1C 0x0         1 if the counter overflowed. Write 1 to clear.
//     ar_qd_uf                       1      25 RW1C 0x0         1 if the counter underflowed. Write 1 to clear.
//     aw_qd_ovf                      1      26 RW1C 0x0         1 if the counter overflowed. Write 1 to clear.
//     aw_qd_uf                       1      27 RW1C 0x0         1 if the counter underflowed. Write 1 to clear.
//     w_qd_ovf                       1      28 RW1C 0x0         1 if the counter overflowed. Write 1 to clear.
//     w_qd_uf                        1      29 RW1C 0x0         1 if the counter underflowed. Write 1 to clear.
//     reset_ctrs                     1      31 RW   0x0         While 1, queue depth and queue depth highwater counters are
//                                                               reset to 0.
//
#define DP_HDMA2SRAM_AXIMON1                                         0x000000000004a010ULL
#define DP_HDMA2SRAM_AXIMON1_ar_qd                                   0x080000000004a010ULL
#define DP_HDMA2SRAM_AXIMON1_aw_qd                                   0x080800000004a010ULL
#define DP_HDMA2SRAM_AXIMON1_w_qd                                    0x081000000004a010ULL
#define DP_HDMA2SRAM_AXIMON1_ar_qd_ovf                               0x011800000004a010ULL
#define DP_HDMA2SRAM_AXIMON1_ar_qd_uf                                0x011900000004a010ULL
#define DP_HDMA2SRAM_AXIMON1_aw_qd_ovf                               0x011a00000004a010ULL
#define DP_HDMA2SRAM_AXIMON1_aw_qd_uf                                0x011b00000004a010ULL
#define DP_HDMA2SRAM_AXIMON1_w_qd_ovf                                0x011c00000004a010ULL
#define DP_HDMA2SRAM_AXIMON1_w_qd_uf                                 0x011d00000004a010ULL
#define DP_HDMA2SRAM_AXIMON1_reset_ctrs                              0x011f00000004a010ULL

//
// Register:    DP_HDMA2SRAM_AXIMON2
// Description: AXI Monitor 2 - Queue depth counter high water marks, read/write error reporting
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     ar_qd_highwater                8   07:00 RO   0x0         Returns the maximum observed queue depth of the AR channel.
//     aw_qd_highwater                8   15:08 RO   0x0         Returns the maximum observed queue depth of the AW channel.
//     w_qd_highwater                 8   23:16 RO   0x0         Returns the maximum observed queue depth of the W channel.
//     rderr                          1      24 RW1C 0x0         1 if an AXI read error occurred. Write 1 to clear.
//     rresp                          2   26:25 RO   0x0         Records the RRESP code observed during the last read error.
//     wrerr                          1      28 RW1C 0x0         1 if an AXI write error occurred. Write 1 to clear.
//     bresp                          2   30:29 RO   0x0         Records the BRESP code observed during the last write error.
//
#define DP_HDMA2SRAM_AXIMON2                                         0x000000000004a014ULL
#define DP_HDMA2SRAM_AXIMON2_ar_qd_highwater                         0x080000000004a014ULL
#define DP_HDMA2SRAM_AXIMON2_aw_qd_highwater                         0x080800000004a014ULL
#define DP_HDMA2SRAM_AXIMON2_w_qd_highwater                          0x081000000004a014ULL
#define DP_HDMA2SRAM_AXIMON2_rderr                                   0x011800000004a014ULL
#define DP_HDMA2SRAM_AXIMON2_rresp                                   0x021900000004a014ULL
#define DP_HDMA2SRAM_AXIMON2_wrerr                                   0x011c00000004a014ULL
#define DP_HDMA2SRAM_AXIMON2_bresp                                   0x021d00000004a014ULL

//
// Register:    DP_HDMA2PCIE_AXIMON1
// Description: AXI Monitor 1 - Queue depth counters and overflow/underflow flags
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     ar_qd                          8   07:00 RO   0x0         Returns the current queue depth of the AR channel.
//     aw_qd                          8   15:08 RO   0x0         Returns the current queue depth of the AW channel.
//     w_qd                           8   23:16 RO   0x0         Returns the current queue depth of the W channel.
//     ar_qd_ovf                      1      24 RW1C 0x0         1 if the counter overflowed. Write 1 to clear.
//     ar_qd_uf                       1      25 RW1C 0x0         1 if the counter underflowed. Write 1 to clear.
//     aw_qd_ovf                      1      26 RW1C 0x0         1 if the counter overflowed. Write 1 to clear.
//     aw_qd_uf                       1      27 RW1C 0x0         1 if the counter underflowed. Write 1 to clear.
//     w_qd_ovf                       1      28 RW1C 0x0         1 if the counter overflowed. Write 1 to clear.
//     w_qd_uf                        1      29 RW1C 0x0         1 if the counter underflowed. Write 1 to clear.
//     reset_ctrs                     1      31 RW   0x0         While 1, queue depth and queue depth highwater counters are
//                                                               reset to 0.
//
#define DP_HDMA2PCIE_AXIMON1                                         0x000000000004a020ULL
#define DP_HDMA2PCIE_AXIMON1_ar_qd                                   0x080000000004a020ULL
#define DP_HDMA2PCIE_AXIMON1_aw_qd                                   0x080800000004a020ULL
#define DP_HDMA2PCIE_AXIMON1_w_qd                                    0x081000000004a020ULL
#define DP_HDMA2PCIE_AXIMON1_ar_qd_ovf                               0x011800000004a020ULL
#define DP_HDMA2PCIE_AXIMON1_ar_qd_uf                                0x011900000004a020ULL
#define DP_HDMA2PCIE_AXIMON1_aw_qd_ovf                               0x011a00000004a020ULL
#define DP_HDMA2PCIE_AXIMON1_aw_qd_uf                                0x011b00000004a020ULL
#define DP_HDMA2PCIE_AXIMON1_w_qd_ovf                                0x011c00000004a020ULL
#define DP_HDMA2PCIE_AXIMON1_w_qd_uf                                 0x011d00000004a020ULL
#define DP_HDMA2PCIE_AXIMON1_reset_ctrs                              0x011f00000004a020ULL

//
// Register:    DP_HDMA2PCIE_AXIMON2
// Description: AXI Monitor 2 - Queue depth counter high water marks, read/write error reporting
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     ar_qd_highwater                8   07:00 RO   0x0         Returns the maximum observed queue depth of the AR channel.
//     aw_qd_highwater                8   15:08 RO   0x0         Returns the maximum observed queue depth of the AW channel.
//     w_qd_highwater                 8   23:16 RO   0x0         Returns the maximum observed queue depth of the W channel.
//     rderr                          1      24 RW1C 0x0         1 if an AXI read error occurred. Write 1 to clear.
//     rresp                          2   26:25 RO   0x0         Records the RRESP code observed during the last read error.
//     wrerr                          1      28 RW1C 0x0         1 if an AXI write error occurred. Write 1 to clear.
//     bresp                          2   30:29 RO   0x0         Records the BRESP code observed during the last write error.
//
#define DP_HDMA2PCIE_AXIMON2                                         0x000000000004a024ULL
#define DP_HDMA2PCIE_AXIMON2_ar_qd_highwater                         0x080000000004a024ULL
#define DP_HDMA2PCIE_AXIMON2_aw_qd_highwater                         0x080800000004a024ULL
#define DP_HDMA2PCIE_AXIMON2_w_qd_highwater                          0x081000000004a024ULL
#define DP_HDMA2PCIE_AXIMON2_rderr                                   0x011800000004a024ULL
#define DP_HDMA2PCIE_AXIMON2_rresp                                   0x021900000004a024ULL
#define DP_HDMA2PCIE_AXIMON2_wrerr                                   0x011c00000004a024ULL
#define DP_HDMA2PCIE_AXIMON2_bresp                                   0x021d00000004a024ULL

//
// Register:    DP_HS2MEM_AXIMON1
// Description: AXI Monitor 1 - Queue depth counters and overflow/underflow flags
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     ar_qd                          8   07:00 RO   0x0         Returns the current queue depth of the AR channel.
//     aw_qd                          8   15:08 RO   0x0         Returns the current queue depth of the AW channel.
//     w_qd                           8   23:16 RO   0x0         Returns the current queue depth of the W channel.
//     ar_qd_ovf                      1      24 RW1C 0x0         1 if the counter overflowed. Write 1 to clear.
//     ar_qd_uf                       1      25 RW1C 0x0         1 if the counter underflowed. Write 1 to clear.
//     aw_qd_ovf                      1      26 RW1C 0x0         1 if the counter overflowed. Write 1 to clear.
//     aw_qd_uf                       1      27 RW1C 0x0         1 if the counter underflowed. Write 1 to clear.
//     w_qd_ovf                       1      28 RW1C 0x0         1 if the counter overflowed. Write 1 to clear.
//     w_qd_uf                        1      29 RW1C 0x0         1 if the counter underflowed. Write 1 to clear.
//     reset_ctrs                     1      31 RW   0x0         While 1, queue depth and queue depth highwater counters are
//                                                               reset to 0.
//
#define DP_HS2MEM_AXIMON1                                            0x000000000004a030ULL
#define DP_HS2MEM_AXIMON1_ar_qd                                      0x080000000004a030ULL
#define DP_HS2MEM_AXIMON1_aw_qd                                      0x080800000004a030ULL
#define DP_HS2MEM_AXIMON1_w_qd                                       0x081000000004a030ULL
#define DP_HS2MEM_AXIMON1_ar_qd_ovf                                  0x011800000004a030ULL
#define DP_HS2MEM_AXIMON1_ar_qd_uf                                   0x011900000004a030ULL
#define DP_HS2MEM_AXIMON1_aw_qd_ovf                                  0x011a00000004a030ULL
#define DP_HS2MEM_AXIMON1_aw_qd_uf                                   0x011b00000004a030ULL
#define DP_HS2MEM_AXIMON1_w_qd_ovf                                   0x011c00000004a030ULL
#define DP_HS2MEM_AXIMON1_w_qd_uf                                    0x011d00000004a030ULL
#define DP_HS2MEM_AXIMON1_reset_ctrs                                 0x011f00000004a030ULL

//
// Register:    DP_HS2MEM_AXIMON2
// Description: AXI Monitor 2 - Queue depth counter high water marks, read/write error reporting
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     ar_qd_highwater                8   07:00 RO   0x0         Returns the maximum observed queue depth of the AR channel.
//     aw_qd_highwater                8   15:08 RO   0x0         Returns the maximum observed queue depth of the AW channel.
//     w_qd_highwater                 8   23:16 RO   0x0         Returns the maximum observed queue depth of the W channel.
//     rderr                          1      24 RW1C 0x0         1 if an AXI read error occurred. Write 1 to clear.
//     rresp                          2   26:25 RO   0x0         Records the RRESP code observed during the last read error.
//     wrerr                          1      28 RW1C 0x0         1 if an AXI write error occurred. Write 1 to clear.
//     bresp                          2   30:29 RO   0x0         Records the BRESP code observed during the last write error.
//
#define DP_HS2MEM_AXIMON2                                            0x000000000004a034ULL
#define DP_HS2MEM_AXIMON2_ar_qd_highwater                            0x080000000004a034ULL
#define DP_HS2MEM_AXIMON2_aw_qd_highwater                            0x080800000004a034ULL
#define DP_HS2MEM_AXIMON2_w_qd_highwater                             0x081000000004a034ULL
#define DP_HS2MEM_AXIMON2_rderr                                      0x011800000004a034ULL
#define DP_HS2MEM_AXIMON2_rresp                                      0x021900000004a034ULL
#define DP_HS2MEM_AXIMON2_wrerr                                      0x011c00000004a034ULL
#define DP_HS2MEM_AXIMON2_bresp                                      0x021d00000004a034ULL

//
// Register:    DP_HS2PCIE_AXIMON1
// Description: AXI Monitor 1 - Queue depth counters and overflow/underflow flags
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     ar_qd                          8   07:00 RO   0x0         Returns the current queue depth of the AR channel.
//     aw_qd                          8   15:08 RO   0x0         Returns the current queue depth of the AW channel.
//     w_qd                           8   23:16 RO   0x0         Returns the current queue depth of the W channel.
//     ar_qd_ovf                      1      24 RW1C 0x0         1 if the counter overflowed. Write 1 to clear.
//     ar_qd_uf                       1      25 RW1C 0x0         1 if the counter underflowed. Write 1 to clear.
//     aw_qd_ovf                      1      26 RW1C 0x0         1 if the counter overflowed. Write 1 to clear.
//     aw_qd_uf                       1      27 RW1C 0x0         1 if the counter underflowed. Write 1 to clear.
//     w_qd_ovf                       1      28 RW1C 0x0         1 if the counter overflowed. Write 1 to clear.
//     w_qd_uf                        1      29 RW1C 0x0         1 if the counter underflowed. Write 1 to clear.
//     reset_ctrs                     1      31 RW   0x0         While 1, queue depth and queue depth highwater counters are
//                                                               reset to 0.
//
#define DP_HS2PCIE_AXIMON1                                           0x000000000004a040ULL
#define DP_HS2PCIE_AXIMON1_ar_qd                                     0x080000000004a040ULL
#define DP_HS2PCIE_AXIMON1_aw_qd                                     0x080800000004a040ULL
#define DP_HS2PCIE_AXIMON1_w_qd                                      0x081000000004a040ULL
#define DP_HS2PCIE_AXIMON1_ar_qd_ovf                                 0x011800000004a040ULL
#define DP_HS2PCIE_AXIMON1_ar_qd_uf                                  0x011900000004a040ULL
#define DP_HS2PCIE_AXIMON1_aw_qd_ovf                                 0x011a00000004a040ULL
#define DP_HS2PCIE_AXIMON1_aw_qd_uf                                  0x011b00000004a040ULL
#define DP_HS2PCIE_AXIMON1_w_qd_ovf                                  0x011c00000004a040ULL
#define DP_HS2PCIE_AXIMON1_w_qd_uf                                   0x011d00000004a040ULL
#define DP_HS2PCIE_AXIMON1_reset_ctrs                                0x011f00000004a040ULL

//
// Register:    DP_HS2PCIE_AXIMON2
// Description: AXI Monitor 2 - Queue depth counter high water marks, read/write error reporting
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     ar_qd_highwater                8   07:00 RO   0x0         Returns the maximum observed queue depth of the AR channel.
//     aw_qd_highwater                8   15:08 RO   0x0         Returns the maximum observed queue depth of the AW channel.
//     w_qd_highwater                 8   23:16 RO   0x0         Returns the maximum observed queue depth of the W channel.
//     rderr                          1      24 RW1C 0x0         1 if an AXI read error occurred. Write 1 to clear.
//     rresp                          2   26:25 RO   0x0         Records the RRESP code observed during the last read error.
//     wrerr                          1      28 RW1C 0x0         1 if an AXI write error occurred. Write 1 to clear.
//     bresp                          2   30:29 RO   0x0         Records the BRESP code observed during the last write error.
//
#define DP_HS2PCIE_AXIMON2                                           0x000000000004a044ULL
#define DP_HS2PCIE_AXIMON2_ar_qd_highwater                           0x080000000004a044ULL
#define DP_HS2PCIE_AXIMON2_aw_qd_highwater                           0x080800000004a044ULL
#define DP_HS2PCIE_AXIMON2_w_qd_highwater                            0x081000000004a044ULL
#define DP_HS2PCIE_AXIMON2_rderr                                     0x011800000004a044ULL
#define DP_HS2PCIE_AXIMON2_rresp                                     0x021900000004a044ULL
#define DP_HS2PCIE_AXIMON2_wrerr                                     0x011c00000004a044ULL
#define DP_HS2PCIE_AXIMON2_bresp                                     0x021d00000004a044ULL

//
// Register:    DP_DP2PCIE_AXIMON1
// Description: AXI Monitor 1 - Queue depth counters and overflow/underflow flags
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     ar_qd                          8   07:00 RO   0x0         Returns the current queue depth of the AR channel.
//     aw_qd                          8   15:08 RO   0x0         Returns the current queue depth of the AW channel.
//     w_qd                           8   23:16 RO   0x0         Returns the current queue depth of the W channel.
//     ar_qd_ovf                      1      24 RW1C 0x0         1 if the counter overflowed. Write 1 to clear.
//     ar_qd_uf                       1      25 RW1C 0x0         1 if the counter underflowed. Write 1 to clear.
//     aw_qd_ovf                      1      26 RW1C 0x0         1 if the counter overflowed. Write 1 to clear.
//     aw_qd_uf                       1      27 RW1C 0x0         1 if the counter underflowed. Write 1 to clear.
//     w_qd_ovf                       1      28 RW1C 0x0         1 if the counter overflowed. Write 1 to clear.
//     w_qd_uf                        1      29 RW1C 0x0         1 if the counter underflowed. Write 1 to clear.
//     reset_ctrs                     1      31 RW   0x0         While 1, queue depth and queue depth highwater counters are
//                                                               reset to 0.
//
#define DP_DP2PCIE_AXIMON1                                           0x000000000004a050ULL
#define DP_DP2PCIE_AXIMON1_ar_qd                                     0x080000000004a050ULL
#define DP_DP2PCIE_AXIMON1_aw_qd                                     0x080800000004a050ULL
#define DP_DP2PCIE_AXIMON1_w_qd                                      0x081000000004a050ULL
#define DP_DP2PCIE_AXIMON1_ar_qd_ovf                                 0x011800000004a050ULL
#define DP_DP2PCIE_AXIMON1_ar_qd_uf                                  0x011900000004a050ULL
#define DP_DP2PCIE_AXIMON1_aw_qd_ovf                                 0x011a00000004a050ULL
#define DP_DP2PCIE_AXIMON1_aw_qd_uf                                  0x011b00000004a050ULL
#define DP_DP2PCIE_AXIMON1_w_qd_ovf                                  0x011c00000004a050ULL
#define DP_DP2PCIE_AXIMON1_w_qd_uf                                   0x011d00000004a050ULL
#define DP_DP2PCIE_AXIMON1_reset_ctrs                                0x011f00000004a050ULL

//
// Register:    DP_DP2PCIE_AXIMON2
// Description: AXI Monitor 2 - Queue depth counter high water marks, read/write error reporting
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     ar_qd_highwater                8   07:00 RO   0x0         Returns the maximum observed queue depth of the AR channel.
//     aw_qd_highwater                8   15:08 RO   0x0         Returns the maximum observed queue depth of the AW channel.
//     w_qd_highwater                 8   23:16 RO   0x0         Returns the maximum observed queue depth of the W channel.
//     rderr                          1      24 RW1C 0x0         1 if an AXI read error occurred. Write 1 to clear.
//     rresp                          2   26:25 RO   0x0         Records the RRESP code observed during the last read error.
//     wrerr                          1      28 RW1C 0x0         1 if an AXI write error occurred. Write 1 to clear.
//     bresp                          2   30:29 RO   0x0         Records the BRESP code observed during the last write error.
//
#define DP_DP2PCIE_AXIMON2                                           0x000000000004a054ULL
#define DP_DP2PCIE_AXIMON2_ar_qd_highwater                           0x080000000004a054ULL
#define DP_DP2PCIE_AXIMON2_aw_qd_highwater                           0x080800000004a054ULL
#define DP_DP2PCIE_AXIMON2_w_qd_highwater                            0x081000000004a054ULL
#define DP_DP2PCIE_AXIMON2_rderr                                     0x011800000004a054ULL
#define DP_DP2PCIE_AXIMON2_rresp                                     0x021900000004a054ULL
#define DP_DP2PCIE_AXIMON2_wrerr                                     0x011c00000004a054ULL
#define DP_DP2PCIE_AXIMON2_bresp                                     0x021d00000004a054ULL

//
// Register:    DP_METADATA2PCIE_AXIMON1
// Description: AXI Monitor 1 - Queue depth counters and overflow/underflow flags
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     ar_qd                          8   07:00 RO   0x0         Returns the current queue depth of the AR channel.
//     aw_qd                          8   15:08 RO   0x0         Returns the current queue depth of the AW channel.
//     w_qd                           8   23:16 RO   0x0         Returns the current queue depth of the W channel.
//     ar_qd_ovf                      1      24 RW1C 0x0         1 if the counter overflowed. Write 1 to clear.
//     ar_qd_uf                       1      25 RW1C 0x0         1 if the counter underflowed. Write 1 to clear.
//     aw_qd_ovf                      1      26 RW1C 0x0         1 if the counter overflowed. Write 1 to clear.
//     aw_qd_uf                       1      27 RW1C 0x0         1 if the counter underflowed. Write 1 to clear.
//     w_qd_ovf                       1      28 RW1C 0x0         1 if the counter overflowed. Write 1 to clear.
//     w_qd_uf                        1      29 RW1C 0x0         1 if the counter underflowed. Write 1 to clear.
//     reset_ctrs                     1      31 RW   0x0         While 1, queue depth and queue depth highwater counters are
//                                                               reset to 0.
//
#define DP_METADATA2PCIE_AXIMON1                                     0x000000000004a060ULL
#define DP_METADATA2PCIE_AXIMON1_ar_qd                               0x080000000004a060ULL
#define DP_METADATA2PCIE_AXIMON1_aw_qd                               0x080800000004a060ULL
#define DP_METADATA2PCIE_AXIMON1_w_qd                                0x081000000004a060ULL
#define DP_METADATA2PCIE_AXIMON1_ar_qd_ovf                           0x011800000004a060ULL
#define DP_METADATA2PCIE_AXIMON1_ar_qd_uf                            0x011900000004a060ULL
#define DP_METADATA2PCIE_AXIMON1_aw_qd_ovf                           0x011a00000004a060ULL
#define DP_METADATA2PCIE_AXIMON1_aw_qd_uf                            0x011b00000004a060ULL
#define DP_METADATA2PCIE_AXIMON1_w_qd_ovf                            0x011c00000004a060ULL
#define DP_METADATA2PCIE_AXIMON1_w_qd_uf                             0x011d00000004a060ULL
#define DP_METADATA2PCIE_AXIMON1_reset_ctrs                          0x011f00000004a060ULL

//
// Register:    DP_METADATA2PCIE_AXIMON2
// Description: AXI Monitor 2 - Queue depth counter high water marks, read/write error reporting
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     ar_qd_highwater                8   07:00 RO   0x0         Returns the maximum observed queue depth of the AR channel.
//     aw_qd_highwater                8   15:08 RO   0x0         Returns the maximum observed queue depth of the AW channel.
//     w_qd_highwater                 8   23:16 RO   0x0         Returns the maximum observed queue depth of the W channel.
//     rderr                          1      24 RW1C 0x0         1 if an AXI read error occurred. Write 1 to clear.
//     rresp                          2   26:25 RO   0x0         Records the RRESP code observed during the last read error.
//     wrerr                          1      28 RW1C 0x0         1 if an AXI write error occurred. Write 1 to clear.
//     bresp                          2   30:29 RO   0x0         Records the BRESP code observed during the last write error.
//
#define DP_METADATA2PCIE_AXIMON2                                     0x000000000004a064ULL
#define DP_METADATA2PCIE_AXIMON2_ar_qd_highwater                     0x080000000004a064ULL
#define DP_METADATA2PCIE_AXIMON2_aw_qd_highwater                     0x080800000004a064ULL
#define DP_METADATA2PCIE_AXIMON2_w_qd_highwater                      0x081000000004a064ULL
#define DP_METADATA2PCIE_AXIMON2_rderr                               0x011800000004a064ULL
#define DP_METADATA2PCIE_AXIMON2_rresp                               0x021900000004a064ULL
#define DP_METADATA2PCIE_AXIMON2_wrerr                               0x011c00000004a064ULL
#define DP_METADATA2PCIE_AXIMON2_bresp                               0x021d00000004a064ULL

//
// Register:    DP_COMPR2PCIE_AXIMON1
// Description: AXI Monitor 1 - Queue depth counters and overflow/underflow flags
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     ar_qd                          8   07:00 RO   0x0         Returns the current queue depth of the AR channel.
//     aw_qd                          8   15:08 RO   0x0         Returns the current queue depth of the AW channel.
//     w_qd                           8   23:16 RO   0x0         Returns the current queue depth of the W channel.
//     ar_qd_ovf                      1      24 RW1C 0x0         1 if the counter overflowed. Write 1 to clear.
//     ar_qd_uf                       1      25 RW1C 0x0         1 if the counter underflowed. Write 1 to clear.
//     aw_qd_ovf                      1      26 RW1C 0x0         1 if the counter overflowed. Write 1 to clear.
//     aw_qd_uf                       1      27 RW1C 0x0         1 if the counter underflowed. Write 1 to clear.
//     w_qd_ovf                       1      28 RW1C 0x0         1 if the counter overflowed. Write 1 to clear.
//     w_qd_uf                        1      29 RW1C 0x0         1 if the counter underflowed. Write 1 to clear.
//     reset_ctrs                     1      31 RW   0x0         While 1, queue depth and queue depth highwater counters are
//                                                               reset to 0.
//
#define DP_COMPR2PCIE_AXIMON1                                        0x000000000004a070ULL
#define DP_COMPR2PCIE_AXIMON1_ar_qd                                  0x080000000004a070ULL
#define DP_COMPR2PCIE_AXIMON1_aw_qd                                  0x080800000004a070ULL
#define DP_COMPR2PCIE_AXIMON1_w_qd                                   0x081000000004a070ULL
#define DP_COMPR2PCIE_AXIMON1_ar_qd_ovf                              0x011800000004a070ULL
#define DP_COMPR2PCIE_AXIMON1_ar_qd_uf                               0x011900000004a070ULL
#define DP_COMPR2PCIE_AXIMON1_aw_qd_ovf                              0x011a00000004a070ULL
#define DP_COMPR2PCIE_AXIMON1_aw_qd_uf                               0x011b00000004a070ULL
#define DP_COMPR2PCIE_AXIMON1_w_qd_ovf                               0x011c00000004a070ULL
#define DP_COMPR2PCIE_AXIMON1_w_qd_uf                                0x011d00000004a070ULL
#define DP_COMPR2PCIE_AXIMON1_reset_ctrs                             0x011f00000004a070ULL

//
// Register:    DP_COMPR2PCIE_AXIMON2
// Description: AXI Monitor 2 - Queue depth counter high water marks, read/write error reporting
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     ar_qd_highwater                8   07:00 RO   0x0         Returns the maximum observed queue depth of the AR channel.
//     aw_qd_highwater                8   15:08 RO   0x0         Returns the maximum observed queue depth of the AW channel.
//     w_qd_highwater                 8   23:16 RO   0x0         Returns the maximum observed queue depth of the W channel.
//     rderr                          1      24 RW1C 0x0         1 if an AXI read error occurred. Write 1 to clear.
//     rresp                          2   26:25 RO   0x0         Records the RRESP code observed during the last read error.
//     wrerr                          1      28 RW1C 0x0         1 if an AXI write error occurred. Write 1 to clear.
//     bresp                          2   30:29 RO   0x0         Records the BRESP code observed during the last write error.
//
#define DP_COMPR2PCIE_AXIMON2                                        0x000000000004a074ULL
#define DP_COMPR2PCIE_AXIMON2_ar_qd_highwater                        0x080000000004a074ULL
#define DP_COMPR2PCIE_AXIMON2_aw_qd_highwater                        0x080800000004a074ULL
#define DP_COMPR2PCIE_AXIMON2_w_qd_highwater                         0x081000000004a074ULL
#define DP_COMPR2PCIE_AXIMON2_rderr                                  0x011800000004a074ULL
#define DP_COMPR2PCIE_AXIMON2_rresp                                  0x021900000004a074ULL
#define DP_COMPR2PCIE_AXIMON2_wrerr                                  0x011c00000004a074ULL
#define DP_COMPR2PCIE_AXIMON2_bresp                                  0x021d00000004a074ULL

//
// Register:    DP_COMPR2PCIE_AXIFLOWMON_CTL
// Description: AXI Flow Monitor Control - Counter clear/freeze and select
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     ctr_data_sel                   5   04:00 RW   0x0         Selects which counter value is read out through
//                                                               DP_COMPR2PCIE_AXIFLOWMON_DATA: 0x00: AW Transfer Counter
//                                                               Bits 31:0 0x01: AW Stall Counter Bits 31:0 0x02: W Transfer
//                                                               Counter Bits 31:0 0x03: W Stall Counter Bits 31:0 0x04: B
//                                                               Transfer Counter Bits 31:0 0x05: B Stall Counter Bits 31:0
//                                                               0x06: AR Transfer Counter Bits 31:0 0x07: AR Stall Counter
//                                                               Bits 31:0 0x08: R Transfer Counter Bits 31:0 0x09: R Stall
//                                                               Counter Bits 31:0 0x10-0x19: Repeats 0x00-0x09, returning
//                                                               the high word (bits 63:32) of the corresponding counter.
//     freeze_ctrs                    1      30 RW   0x0         While 1, flow counter values are frozen. Use this to
//                                                               stabilize counters during readout.
//     clr_ctrs                       1      31 RW   0x0         While 1, flow counters are continuously reset to 0.
//
#define DP_COMPR2PCIE_AXIFLOWMON_CTL                                 0x000000000004a080ULL
#define DP_COMPR2PCIE_AXIFLOWMON_CTL_ctr_data_sel                    0x050000000004a080ULL
#define DP_COMPR2PCIE_AXIFLOWMON_CTL_freeze_ctrs                     0x011e00000004a080ULL
#define DP_COMPR2PCIE_AXIFLOWMON_CTL_clr_ctrs                        0x011f00000004a080ULL

//
// Register:    DP_COMPR2PCIE_AXIFLOWMON_DATA
// Description: AXI Flow Monitor Data - Readout for flow counter values
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RO   0x0         Returns the 32-bit slice of a counter selected by
//                                                               DP_COMPR2PCIE_AXIFLOWMON_CTL_ctr_data_sel.
//
#define DP_COMPR2PCIE_AXIFLOWMON_DATA                                0x000000000004a084ULL
#define DP_COMPR2PCIE_AXIFLOWMON_DATA_data                           0x200000000004a084ULL

//
// Register:    DP_DP2PCIE_AXIFLOWMON_CTL
// Description: AXI Flow Monitor Control - Counter clear/freeze and select
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     ctr_data_sel                   5   04:00 RW   0x0         Selects which counter value is read out through
//                                                               DP_DP2PCIE_AXIFLOWMON_DATA: 0x00: AW Transfer Counter Bits
//                                                               31:0 0x01: AW Stall Counter Bits 31:0 0x02: W Transfer
//                                                               Counter Bits 31:0 0x03: W Stall Counter Bits 31:0 0x04: B
//                                                               Transfer Counter Bits 31:0 0x05: B Stall Counter Bits 31:0
//                                                               0x06: AR Transfer Counter Bits 31:0 0x07: AR Stall Counter
//                                                               Bits 31:0 0x08: R Transfer Counter Bits 31:0 0x09: R Stall
//                                                               Counter Bits 31:0 0x10-0x19: Repeats 0x00-0x09, returning
//                                                               the high word (bits 63:32) of the corresponding counter.
//     freeze_ctrs                    1      30 RW   0x0         While 1, flow counter values are frozen. Use this to
//                                                               stabilize counters during readout.
//     clr_ctrs                       1      31 RW   0x0         While 1, flow counters are continuously reset to 0.
//
#define DP_DP2PCIE_AXIFLOWMON_CTL                                    0x000000000004a090ULL
#define DP_DP2PCIE_AXIFLOWMON_CTL_ctr_data_sel                       0x050000000004a090ULL
#define DP_DP2PCIE_AXIFLOWMON_CTL_freeze_ctrs                        0x011e00000004a090ULL
#define DP_DP2PCIE_AXIFLOWMON_CTL_clr_ctrs                           0x011f00000004a090ULL

//
// Register:    DP_DP2PCIE_AXIFLOWMON_DATA
// Description: AXI Flow Monitor Data - Readout for flow counter values
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RO   0x0         Returns the 32-bit slice of a counter selected by
//                                                               DP_DP2PCIE_AXIFLOWMON_CTL_ctr_data_sel.
//
#define DP_DP2PCIE_AXIFLOWMON_DATA                                   0x000000000004a094ULL
#define DP_DP2PCIE_AXIFLOWMON_DATA_data                              0x200000000004a094ULL

//
// Register:    DP_HS_CFG
// Description: High Speed interface configuration
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     enable                         1       0 RW   0x0         0: The HS SMEM update engine is idle and all config changes
//                                                               are permitted. 1: Enables the update engine, and ignore
//                                                               changes to host_buffer_mode, quad_buffer_mode, and the host
//                                                               buffer pointers. NOTE: If this bit changes to 0 while a SMEM
//                                                               update is in progress, the update is allowed to complete
//                                                               before the engine goes to sleep and unlocks configuration
//                                                               changes. For this reason, to shut down, software should
//                                                               write this bit to 0 and then wait until DP_HS_STATUS_enabled
//                                                               reads 0 before attempting to change protected configuration.
//     host_buffer_mode               1       1 RW   0x0         0: Reads compacted ABM data from FPGA DRAM CABM buffers. 1:
//                                                               Reads CABM data from host memory buffers configured through
//                                                               the DP_HS_HOSTBUF_PTR_* registers. In both modes, CABM data
//                                                               is expanded with RBM data read from FPGA DRAM RBM buffers,
//                                                               and the expanded data is written to both chip SMEM and FPGA
//                                                               DRAM mirror buffers. WARNING: Do not turn on host buffer
//                                                               mode before configuring the pointers.
//     quad_buffer_mode               1       2 RW   0x0         0: dual-buffer mode. 1: quad-buffer mode. In dual-buffer
//                                                               mode, the quadrant 0 buffer pointer is used for phase 0, the
//                                                               q2 buffer pointer for phase 1, and the q1 and q3 pointers
//                                                               are unused.  In quad buffer mode, the q0 pointer is used for
//                                                               chip rows 0-127, q1 for 128-255, q2 for 256-383, and q3 for
//                                                               384-511. NOTE: This bit is ignored while host_buffer_mode is
//                                                               0 since the FPGA deac engines do not support quad buffer
//                                                               mode.
//     invalidate_mirror_buffers      1       4 RW   0x0         While 1: Clear all DP_HS_STATUS_qN_mirror_synced bits. Once
//                                                               a mirror buffer is synced to chip SMEM contents, it is used
//                                                               to filter future writes to the chip. This reduces HS bus
//                                                               traffic since there is no need to transmit anything to the
//                                                               chip if a portion of the ABM has not changed since the
//                                                               previous update. If left at 1 permanently, this mode bit
//                                                               forces all update passes to be full writes with no
//                                                               filtering, If written from 0 to 1 to 0, the next update pass
//                                                               for each quadrant will be unfiltered and subsequent update
//                                                               passes will be filtered. NOTE: When performing an initial
//                                                               load of SMEM contents, this bit should be used to guarantee
//                                                               that nothing gets filtered out.
//     continuous_updates             1       5 RW   0x0         0: Updates are requested by writes to DP_HS_UPDATE_REQ. 1:
//                                                               Updates are triggered by a periodic timer (see
//                                                               DP_HS_CFG_TIMER)
//
#define DP_HS_CFG                                                    0x000000000004f000ULL
#define DP_HS_CFG_enable                                             0x010000000004f000ULL
#define DP_HS_CFG_host_buffer_mode                                   0x010100000004f000ULL
#define DP_HS_CFG_quad_buffer_mode                                   0x010200000004f000ULL
#define DP_HS_CFG_invalidate_mirror_buffers                          0x010400000004f000ULL
#define DP_HS_CFG_continuous_updates                                 0x010500000004f000ULL

//
// Register:    DP_HS_CFG_TIMER
// Description: Set the period between continuous mode updates
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     update_interval                28  27:00 RW   0x0         While DP_HS_CFG_continuous_updates is set to 1, a timer
//                                                               governs how often SMEM updates are performed. This field
//                                                               configures the timer's period in units of 4ns (250 MHz clock
//                                                               cycles). Example: to start an update pass every 0.1s, set to
//                                                               0.1s / 4ns = 25,000,000 decimal. If set to any value shorter
//                                                               than the time it takes to complete an update, the next
//                                                               update will start immediately.
//
#define DP_HS_CFG_TIMER                                              0x000000000004f004ULL
#define DP_HS_CFG_TIMER_update_interval                              0x1c0000000004f004ULL

//
// Register:    DP_HS_STATUS
// Description: High Speed interface status
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     q0_update_scheduled            1       0 RO   0x0         Quadrant 0 (phase 0) update scheduled. This means the auto
//                                                               update engine will run an update pass for this
//                                                               quadrant/phase at some time in the future.  Always reads 1
//                                                               while DP_HS_CFG_host_buffer_mode is 1.
//     q1_update_scheduled            1       1 RO   0x0         Quadrant 1 (phase 0) update scheduled
//     q2_update_scheduled            1       2 RO   0x0         Quadrant 2 (phase 1) update scheduled
//     q3_update_scheduled            1       3 RO   0x0         Quadrant 3 (phase 1) update scheduled
//     q0_update_in_progress          1       4 RO   0x0         1: Quadrant 0 (phase 0) update in progress
//     q1_update_in_progress          1       5 RO   0x0         1: Quadrant 1 (phase 0) update in progress
//     q2_update_in_progress          1       6 RO   0x0         1: Quadrant 2 (phase 1) update in progress
//     q3_update_in_progress          1       7 RO   0x0         1: Quadrant 3 (phase 1) update in progress
//     q0_mirror_synced               1       8 RO   0x0         1: Chip SMEM quadrant 0 (phase 0) is synchronized with the
//                                                               FPGA mirror buffer. Future updates of this quadrant will be
//                                                               sent to the chip as deltas (mirror buffer is used to filter
//                                                               transmission of data the chip already has). Set on update
//                                                               pass completion. Cleared by
//                                                               DP_HS_CFG_invalidate_mirror_buffers=1, chip power off, chip
//                                                               hardware reset assertion, or a SMEM load request from
//                                                               DP_HS_CFG_load_req. Clear overrides set.
//     q1_mirror_synced               1       9 RO   0x0         1: Chip SMEM quadrant 1 (phase 0) is synchronized with the
//                                                               FPGA mirror buffer.
//     q2_mirror_synced               1      10 RO   0x0         1: Chip SMEM quadrant 2 (phase 1) is synchronized with the
//                                                               FPGA mirror buffer.
//     q3_mirror_synced               1      11 RO   0x0         1: Chip SMEM quadrant 3 (phase 1) is synchronized with the
//                                                               FPGA mirror buffer.
//     enabled                        1      16 RO   0x0         Reads 1 while the HS SMEM update engine is enabled. May read
//                                                               1 for a short time after the enable bit in DP_HS_CFG is
//                                                               written to 0.
//     host_buffer_mode               1      17 RO   0x0         Reads 1 while the HS SMEM update engine is configured for
//                                                               host buffer mode. Useful for determining how the hardware is
//                                                               actually configured while DP_HS_STATUS_enabled is 1.
//     quad_buffer_mode               1      18 RO   0x0         Reads 1 while the HS SMEM update engine is configured for
//                                                               quad buffer mode. Useful for determining how the hardware is
//                                                               actually configured while DP_HS_STATUS_enabled is 1.
//
#define DP_HS_STATUS                                                 0x000000000004f00cULL
#define DP_HS_STATUS_q0_update_scheduled                             0x010000000004f00cULL
#define DP_HS_STATUS_q1_update_scheduled                             0x010100000004f00cULL
#define DP_HS_STATUS_q2_update_scheduled                             0x010200000004f00cULL
#define DP_HS_STATUS_q3_update_scheduled                             0x010300000004f00cULL
#define DP_HS_STATUS_q0_update_in_progress                           0x010400000004f00cULL
#define DP_HS_STATUS_q1_update_in_progress                           0x010500000004f00cULL
#define DP_HS_STATUS_q2_update_in_progress                           0x010600000004f00cULL
#define DP_HS_STATUS_q3_update_in_progress                           0x010700000004f00cULL
#define DP_HS_STATUS_q0_mirror_synced                                0x010800000004f00cULL
#define DP_HS_STATUS_q1_mirror_synced                                0x010900000004f00cULL
#define DP_HS_STATUS_q2_mirror_synced                                0x010a00000004f00cULL
#define DP_HS_STATUS_q3_mirror_synced                                0x010b00000004f00cULL
#define DP_HS_STATUS_enabled                                         0x011000000004f00cULL
#define DP_HS_STATUS_host_buffer_mode                                0x011100000004f00cULL
#define DP_HS_STATUS_quad_buffer_mode                                0x011200000004f00cULL

//
// Register:    DP_HS_HOSTBUF_PTR_SEL
// Description: High Speed interface host buffer pointer select
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     quadrant_sel                   2   01:00 RW   0x0         Selects which quadrant’s buffer pointer to read and write
//                                                               through _WRDAT and _RDDAT. Note that in dual buffer mode,
//                                                               quadrant 0’s pointer is used for a single buffer covering
//                                                               all of phase 0, quadrant 2’s pointer is used for phase 1,
//                                                               and the quadrant 1 and 3 pointers are unused.
//     high_word_sel                  1       2 RW   0x0         If 0, access the low word (bits 31:0) of the buffer pointer
//                                                               selected by quadrant_sel. If 1, access the high word (bits
//                                                               63:32).
//
#define DP_HS_HOSTBUF_PTR_SEL                                        0x000000000004f010ULL
#define DP_HS_HOSTBUF_PTR_SEL_quadrant_sel                           0x020000000004f010ULL
#define DP_HS_HOSTBUF_PTR_SEL_high_word_sel                          0x010200000004f010ULL

//
// Register:    DP_HS_HOSTBUF_PTR_WRDAT
// Description: High Speed interface host buffer pointer write data
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RW   0x0         Write to this register to change the pointer word selected
//                                                               by DP_HS_HOSTBUF_PTR_SEL. NOTE: Buffer pointer changes are
//                                                               only accepted while DP_HS_STATUS_enabled reads 0.
//
#define DP_HS_HOSTBUF_PTR_WRDAT                                      0x000000000004f014ULL
#define DP_HS_HOSTBUF_PTR_WRDAT_data                                 0x200000000004f014ULL

//
// Register:    DP_HS_HOSTBUF_PTR_RDDAT
// Description: High Speed interface Host buffer pointer read data
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RO   0x0         Reads the host buffer pointer word selected by
//                                                               DP_HS_HOSTBUF_PTR_SEL.
//
#define DP_HS_HOSTBUF_PTR_RDDAT                                      0x000000000004f01cULL
#define DP_HS_HOSTBUF_PTR_RDDAT_data                                 0x200000000004f01cULL

//
// Register:    DP_HS_UPDATE_REQ
// Description: HS update request
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     mask                           4   03:00 RW   0x0         Writing a bitmask value to this register requests an update
//                                                               pass in all quadrants whose bit is set to 1. Quadrant 0 is
//                                                               bit 0, q1 is bit 1, and so forth. The corresponding
//                                                               qN_update_scheduled bits in DP_HS_STATUS will read 1 until
//                                                               the update engine honors the request.  Example: To request
//                                                               updates of buffer quadrants 0 and 3, write 0x9. (Note:
//                                                               writing a bit to 0 does not de-schedule a previously
//                                                               scheduled update.)
//
#define DP_HS_UPDATE_REQ                                             0x000000000004f020ULL
#define DP_HS_UPDATE_REQ_mask                                        0x040000000004f020ULL

//
// Register:    DP_HS_UPDATE_CTR
// Description: HS update counter
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     count                          32  31:00 RO   0x0         Reports the number of updates performed by the HS SMEM
//                                                               update engine since it was last turned on. Cleared whenever
//                                                               DP_HS_CFG_enable transitions from 0 to 1.
//
#define DP_HS_UPDATE_CTR                                             0x000000000004f024ULL
#define DP_HS_UPDATE_CTR_count                                       0x200000000004f024ULL

//
// Register:    QSFP_RING_FD_ADDR_HI
// Description: QSFP Ring Frame Data address high
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RW   0x0         QSFP Ring frame data address high 63:32
//
#define QSFP_RING_FD_ADDR_HI                                         0x0000000000050000ULL
#define QSFP_RING_FD_ADDR_HI_data                                    0x2000000000050000ULL

//
// Register:    QSFP_RING_FD_ADDR_LO
// Description: QSFP Ring Frame Data address low
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RW   0x0         QSFP Ring frame data address low 63:32
//
#define QSFP_RING_FD_ADDR_LO                                         0x0000000000050004ULL
#define QSFP_RING_FD_ADDR_LO_data                                    0x2000000000050004ULL

//
// Register:    QSFP_RING_FD_SIZE_HI
// Description: QSFP Ring Frame Data size high
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RW   0x0         QSFP Ring frame data size high 63:32
//
#define QSFP_RING_FD_SIZE_HI                                         0x0000000000050008ULL
#define QSFP_RING_FD_SIZE_HI_data                                    0x2000000000050008ULL

//
// Register:    QSFP_RING_FD_SIZE_LO
// Description: QSFP Ring Frame Data size low
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RW   0x0         QSFP Ring frame data size low 63:32
//
#define QSFP_RING_FD_SIZE_LO                                         0x000000000005000cULL
#define QSFP_RING_FD_SIZE_LO_data                                    0x200000000005000cULL

//
// Register:    QSFP_RING_MD_ADDR_HI
// Description: QSFP Ring Meta Data address high
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RW   0x0         QSFP Ring meta data address high 63:32
//
#define QSFP_RING_MD_ADDR_HI                                         0x0000000000050010ULL
#define QSFP_RING_MD_ADDR_HI_data                                    0x2000000000050010ULL

//
// Register:    QSFP_RING_MD_ADDR_LO
// Description: QSFP Ring Meta Data address low
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RW   0x0         QSFP Ring meta data address low 63:32
//
#define QSFP_RING_MD_ADDR_LO                                         0x0000000000050014ULL
#define QSFP_RING_MD_ADDR_LO_data                                    0x2000000000050014ULL

//
// Register:    QSFP_RING_MD_SIZE_HI
// Description: QSFP Ring Meta Data size high
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RW   0x0         QSFP Ring meta data size high 63:32
//
#define QSFP_RING_MD_SIZE_HI                                         0x0000000000050018ULL
#define QSFP_RING_MD_SIZE_HI_data                                    0x2000000000050018ULL

//
// Register:    QSFP_RING_MD_SIZE_LO
// Description: QSFP Ring Meta Data size low
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RW   0x0         QSFP Ring meta data size low 63:32
//
#define QSFP_RING_MD_SIZE_LO                                         0x000000000005001cULL
#define QSFP_RING_MD_SIZE_LO_data                                    0x200000000005001cULL

//
// Register:    QSFP_FC_ADDR_HI
// Description: QSFP Ring Frame Counter address high
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RW   0x0         QSFP Ring frame countee address high 63:32
//
#define QSFP_FC_ADDR_HI                                              0x0000000000050020ULL
#define QSFP_FC_ADDR_HI_data                                         0x2000000000050020ULL

//
// Register:    QSFP_FC_ADDR_LO
// Description: QSFP Ring Frame Counter address low
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RW   0x0         QSFP Ring frame countee address low 63:32
//
#define QSFP_FC_ADDR_LO                                              0x0000000000050024ULL
#define QSFP_FC_ADDR_LO_data                                         0x2000000000050024ULL

//
// Register:    QSFP_FRAME_SIZE
// Description: QSFP Frame size
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RW   0x0         QSFP Frame size
//
#define QSFP_FRAME_SIZE                                              0x0000000000050028ULL
#define QSFP_FRAME_SIZE_data                                         0x2000000000050028ULL

//
// Register:    QSFP_PACKET_SIZE
// Description: QSFP Packet size
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           16  15:00 RW   0x0         QSFP Packet size
//
#define QSFP_PACKET_SIZE                                             0x000000000005002cULL
#define QSFP_PACKET_SIZE_data                                        0x100000000005002cULL

//
// Register:    QSFP_PKTS_PER_GRP
// Description: QSFP Packets Per Group
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     data                           32  31:00 RW   0x0         QSFP Packets Per Group
//
#define QSFP_PKTS_PER_GRP                                            0x0000000000050030ULL
#define QSFP_PKTS_PER_GRP_data                                       0x2000000000050030ULL

//
// Register:    QSFP1_STATUS1
// Description: QSFP1 Status1 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     rx_aligned                     1       0 RO   0x0         Rx Aligned
//
#define QSFP1_STATUS1                                                0x0000000000050040ULL
#define QSFP1_STATUS1_rx_aligned                                     0x0100000000050040ULL

//
// Register:    QSFP1_STATUS2
// Description: QSFP1 Status2 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     pkt_dfifo_full                 1       0 RO   0x0         Packet Data FIFO Full
//
#define QSFP1_STATUS2                                                0x0000000000050044ULL
#define QSFP1_STATUS2_pkt_dfifo_full                                 0x0100000000050044ULL

//
// Register:    QSFP2_STATUS1
// Description: QSFP2 Status1 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     rx_aligned                     1       0 RO   0x0         Rx Aligned
//
#define QSFP2_STATUS1                                                0x0000000000050050ULL
#define QSFP2_STATUS1_rx_aligned                                     0x0100000000050050ULL

//
// Register:    QSFP2_STATUS2
// Description: QSFP2 Status2 Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     pkt_dfifo_full                 1       0 RO   0x0         Packet Data FIFO Full
//
#define QSFP2_STATUS2                                                0x0000000000050054ULL
#define QSFP2_STATUS2_pkt_dfifo_full                                 0x0100000000050054ULL

//
// Register:    ETH0_FRAME_COUNT
// Description: ETH0 Frame Count Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     eth0_frame_count               32  31:00 RO   0x0         Ethernet0 Frame Counter
//
#define ETH0_FRAME_COUNT                                             0x0000000000050058ULL
#define ETH0_FRAME_COUNT_eth0_frame_count                            0x2000000000050058ULL

//
// Register:    ETH1_FRAME_COUNT
// Description: ETH1 Frame Count Register
// Fields:
//     NAME                           WID   POS TYPE RESET       DESCRIPTION
//     eth1_frame_count               32  31:00 RO   0x0         Ethernet1 Frame Counter
//
#define ETH1_FRAME_COUNT                                             0x000000000005005cULL
#define ETH1_FRAME_COUNT_eth1_frame_count                            0x200000000005005cULL


#endif /* _FPGA_REG_H */

